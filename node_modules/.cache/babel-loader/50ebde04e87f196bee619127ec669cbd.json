{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('satellite.js')) : typeof define === 'function' && define.amd ? define(['exports', 'satellite.js'], factory) : (global = global || self, factory(global.tlejs = {}, global.satellite));\n})(this, function (exports, satellite_js) {\n  'use strict';\n\n  const _MS_IN_A_DAY = 86400000;\n  const _MS_IN_A_SECOND = 1000;\n  const _MS_IN_A_MINUTE = 60000; // Data formats for TLE orbital elements.\n\n  const _TLE_DATA_TYPES = {\n    _INT: Symbol(),\n    _FLOAT: Symbol(),\n    _CHAR: Symbol(),\n    _DECIMAL_ASSUMED: Symbol(),\n    // 12345   -> 0.12345\n    _DECIMAL_ASSUMED_E: Symbol() // 12345-2 -> 0.0012345\n\n  };\n  const _DATA_TYPES = {\n    _ARRAY: \"array\",\n    _STRING: \"string\",\n    _OBJECT: \"object\",\n    _DATE: \"date\",\n    _NAN: \"NaN\"\n  };\n  /**\n   * General helper that provides more useful info than JavaScript's built-in \"typeof\" operator.\n   *\n   * Example:\n   * getType([]);\n   * -> 'array'\n   */\n\n  function getType(input) {\n    const type = typeof input;\n\n    if (Array.isArray(input)) {\n      return _DATA_TYPES._ARRAY;\n    }\n\n    if (input instanceof Date) {\n      return _DATA_TYPES._DATE;\n    }\n\n    if (Number.isNaN(input)) {\n      return _DATA_TYPES._NAN;\n    }\n\n    return type;\n  }\n  /**\n   * Determines if a number is positive.\n   */\n\n\n  const _isPositive = num => num >= 0;\n  /**\n   * Determines the amount of digits in a number.  Used for converting a TLE's \"leading decimal\n   * assumed\" notation.\n   *\n   * Example:\n   * getDigitCount(12345);\n   * -> 5\n   */\n\n\n  const _getDigitCount = num => {\n    const absVal = Math.abs(num);\n    return absVal.toString().length;\n  };\n  /**\n   * Converts a TLE's \"leading decimal assumed\" notation to a float representation.\n   *\n   * Example:\n   * toLeadingDecimal(12345);\n   * -> 0.12345\n   */\n\n\n  const _toLeadingDecimal = num => {\n    const numDigits = _getDigitCount(num);\n\n    const zeroes = \"0\".repeat(numDigits - 1);\n    return parseFloat(num * `0.${zeroes}1`);\n  };\n  /**\n   * Converts a TLE's \"leading decimal assumed\" notation with leading zeroes to a float\n   * representation.\n   *\n   * Example:\n   * decimalAssumedEToFloat('12345-4');\n   * -> 0.000012345\n   */\n\n\n  const _decimalAssumedEToFloat = str => {\n    const numWithAssumedLeadingDecimal = str.substr(0, str.length - 2);\n\n    const num = _toLeadingDecimal(numWithAssumedLeadingDecimal);\n\n    const leadingDecimalPoints = parseInt(str.substr(str.length - 2, 2), 10);\n    const float = num * Math.pow(10, leadingDecimalPoints);\n    return parseFloat(float.toPrecision(5));\n  };\n  /**\n   * Converts a fractional day of the year to a timestamp.  Used for parsing the TLE epoch.\n   */\n\n\n  const _dayOfYearToTimeStamp = (dayOfYear, year = new Date().getFullYear()) => {\n    const yearStart = new Date(`1/1/${year} 0:0:0 Z`);\n    const yearStartMS = yearStart.getTime();\n    return Math.floor(yearStartMS + (dayOfYear - 1) * _MS_IN_A_DAY);\n  };\n  /**\n   * Converts radians (0 to 2π) to degrees (0 to 360).\n   */\n\n\n  const _radiansToDegrees = radians => radians * (180 / Math.PI);\n  /**\n   * Converts degrees (0 to 360) to radians (0 to 2π).\n   */\n\n\n  const _degreesToRadians = degrees => degrees * (Math.PI / 180);\n  /**\n   * Determines if a pair of longitude points crosses over the antemeridian, which is a\n   * pain point for mapping software.\n   */\n\n\n  const _crossesAntemeridian = (longitude1, longitude2) => {\n    if (!longitude1 || !longitude2) return false;\n\n    const isLong1Positive = _isPositive(longitude1);\n\n    const isLong2Positive = _isPositive(longitude2);\n\n    const haveSameSigns = isLong1Positive === isLong2Positive;\n    if (haveSameSigns) return false; // Signs don't match, so check if we're reasonably near the antemeridian (just to be sure it's\n    // not the prime meridian).\n\n    const isNearAntemeridian = Math.abs(longitude1) > 100;\n    return isNearAntemeridian;\n  };\n  /**\n   * Note: TLEs have a year 2000 style problem in 2057, because they only represent years in 2\n   * characters.  This function doesn't account for that problem.\n   *\n   * Example:\n   * _getFullYear(98);\n   * -> 1998\n   *\n   * @param {Number} twoDigitYear\n   */\n\n\n  function _getFullYear(twoDigitYear) {\n    const twoDigitYearInt = parseInt(twoDigitYear, 10);\n    return twoDigitYearInt < 100 && twoDigitYearInt > 56 ? twoDigitYearInt + 1900 : twoDigitYearInt + 2000;\n  }\n  /**\n   * Gets a piece of data directly from a TLE line string, and attempts to parse it based on\n   * data format.\n   *\n   * @param {Object} parsedTLE\n   * @param {(1|2)} lineNumber TLE line number.\n   * @param {Object} definition From line-1-definitions or line-2-definitions.\n   */\n\n\n  function getFromTLE(parsedTLE, lineNumber, definition) {\n    const {\n      name,\n      tle\n    } = parsedTLE;\n    const line = lineNumber === 1 ? tle[0] : tle[1];\n    const {\n      start,\n      length,\n      type\n    } = definition;\n    const val = line.substr(start, length);\n    let output;\n\n    switch (type) {\n      case _TLE_DATA_TYPES._INT:\n        output = parseInt(val, 10);\n        break;\n\n      case _TLE_DATA_TYPES._FLOAT:\n        output = parseFloat(val);\n        break;\n\n      case _TLE_DATA_TYPES._DECIMAL_ASSUMED:\n        output = parseFloat(`0.${val}`);\n        break;\n\n      case _TLE_DATA_TYPES._DECIMAL_ASSUMED_E:\n        output = _decimalAssumedEToFloat(val);\n        break;\n\n      case _TLE_DATA_TYPES._CHAR:\n      default:\n        output = val.trim();\n        break;\n    }\n\n    return output;\n  }\n\n  const _ERRORS = {\n    _TYPE: (context = \"\", expected = [], got = \"\") => `${context} must be of type [${expected.join(\", \")}], but got ${got}.`,\n    _NOT_PARSED_OBJECT: `Input object is malformed (should have name and tle properties).`\n  };\n\n  function isTLEObj(obj) {\n    return typeof obj === _DATA_TYPES._OBJECT && obj.name && obj.tle && getType(obj.tle) === _DATA_TYPES._ARRAY && obj.tle.length === 2;\n  } // For TLE parsing memoization.\n\n\n  const tleCache = {};\n  /**\n   * Converts string and array TLE formats into a \"parsed\" TLE in a consistent object format.\n   * Accepts 2 and 3-line (with satellite name) TLE variants in string (\\n-delimited) and array\n   * forms.\n   *\n   * Example:\n   * parseTLE(`ISS (ZARYA)\n   * 1 25544U 98067A   19285.67257269  .00001247  00000-0  29690-4 0  9993\n   * 2 25544  51.6439 138.6866 0007415 141.2524 326.3533 15.50194187193485`);\n   * ->\n   * {\n   *   name: 'ISS (ZARYA)',\n   *   tle: [\n   *     '1 25544U 98067A   19285.67257269  .00001247  00000-0  29690-4 0  9993',\n   *     '2 25544  51.6439 138.6866 0007415 141.2524 326.3533 15.50194187193485'\n   *   ]\n   * }\n   */\n\n  const acceptedTLETypes = [_DATA_TYPES._ARRAY, _DATA_TYPES._STRING, _DATA_TYPES._OBJECT];\n\n  function parseTLE(sourceTLE) {\n    const type = getType(sourceTLE);\n    const output = {};\n    let tleArray = [];\n    const alreadyParsed = isTLEObj(sourceTLE);\n\n    if (alreadyParsed) {\n      // This TLE has already been parsed, so there's nothing left to do.\n      return sourceTLE;\n    }\n\n    const isUnexpectedObject = !alreadyParsed && type === _DATA_TYPES._OBJECT;\n\n    if (isUnexpectedObject) {\n      // TLE is in an unexpected object format.\n      throw new Error(_ERRORS._NOT_PARSED_OBJECT);\n    } // Note: only strings and arrays will make it past this point.\n    // Check if the TLE exists in the cache.\n\n\n    const cacheKey = type === _DATA_TYPES._ARRAY ? sourceTLE[0] : sourceTLE;\n\n    if (tleCache[cacheKey]) {\n      return tleCache[cacheKey];\n    }\n\n    if (!acceptedTLETypes.includes(type)) {\n      throw new Error(_ERRORS._TYPE(\"Source TLE\", acceptedTLETypes, type));\n    } // Convert to array.\n\n\n    if (type === _DATA_TYPES._STRING) {\n      tleArray = sourceTLE.split(\"\\n\");\n    } else if (type === _DATA_TYPES._ARRAY) {\n      // Already an array, so make a copy so we don't mutate the input.\n      tleArray = Array.from(sourceTLE);\n    } // 3-line variant: remove name from array for consistency.\n\n\n    if (tleArray.length === 3) {\n      const name = tleArray[0].trim();\n      tleArray = tleArray.slice(1); // Preserve original name string for use in the getSatelliteName() getter.\n\n      output.name = name;\n    }\n\n    output.tle = tleArray.map(line => line.trim()); // Update cache.\n\n    tleCache[cacheKey] = output;\n    return output;\n  }\n  /**\n   * Determines the checksum for a single line of a TLE.\n   *\n   * Checksum = modulo 10 of sum of all numbers (including line number) + 1 for each negative\n   * sign (-).  Everything else is ignored.\n   */\n\n\n  function computeChecksum(tleLineStr) {\n    const charArr = tleLineStr.split(\"\"); // Remove trailing checksum.\n\n    charArr.splice(charArr.length - 1, 1);\n\n    if (charArr.length === 0) {\n      throw new Error(\"Character array empty!\", tleLineStr);\n    }\n\n    const checksum = charArr.reduce((sum, val) => {\n      const parsedVal = parseInt(val, 10);\n      const parsedSum = parseInt(sum, 10);\n\n      if (Number.isInteger(parsedVal)) {\n        return parsedSum + parsedVal;\n      }\n\n      if (val === \"-\") {\n        return parsedSum + 1;\n      }\n\n      return parsedSum;\n    });\n    return checksum % 10;\n  }\n\n  function lineNumberIsValid(tleObj, lineNumber) {\n    const {\n      tle\n    } = tleObj;\n    return lineNumber === parseInt(tle[lineNumber - 1][0], 10);\n  }\n\n  function checksumIsValid(tleObj, lineNumber) {\n    const {\n      tle\n    } = tleObj;\n    const tleLine = tle[lineNumber - 1];\n    const checksumInTLE = parseInt(tleLine[tleLine.length - 1], 10);\n    const computedChecksum = computeChecksum(tle[lineNumber - 1]);\n    return computedChecksum === checksumInTLE;\n  }\n  /**\n   * Determines if a TLE is structurally valid.\n   */\n\n\n  function isValidTLE(rawTLE) {\n    let tleObj;\n\n    try {\n      tleObj = parseTLE(rawTLE);\n    } catch (e) {\n      return false;\n    } // Line number checks.\n\n\n    const line1NumberIsValid = lineNumberIsValid(tleObj, 1);\n    const line2NumberIsValid = lineNumberIsValid(tleObj, 2);\n\n    if (!line1NumberIsValid || !line2NumberIsValid) {\n      return false;\n    } // Checksums\n\n\n    const line1ChecksumIsValid = checksumIsValid(tleObj, 1);\n    const line2ChecksumIsValid = checksumIsValid(tleObj, 2);\n\n    if (!line1ChecksumIsValid || !line2ChecksumIsValid) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Two-Line Element Set (TLE) format definitions, Line 1\n   * See https://en.wikipedia.org/wiki/Two-line_element_set and https://celestrak.com/columns/v04n03/\n   */\n\n  /* TLE line number. Will always return 1 for valid TLEs. */\n\n\n  const lineNumber1 = {\n    start: 0,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * NORAD satellite catalog number (e.g. Sputnik's rocket was number 00001).\n   * See https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n   *\n   * Range: 0 to 99999\n   * Example: 25544\n   */\n\n  const catalogNumber1 = {\n    start: 2,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Satellite classification.\n   * 'U' = unclassified\n   * 'C' = classified\n   * 'S' = secret\n   *\n   * Example: 'U'\n   */\n\n  const classification = {\n    start: 7,\n    length: 1,\n    type: _TLE_DATA_TYPES._CHAR\n  };\n  /**\n   * International Designator (COSPAR ID): Last 2 digits of launch year.\n   * 57 to 99 = 1900s, 00-56 = 2000s\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: 00 to 99\n   * Example: 98\n   */\n\n  const intDesignatorYear = {\n    start: 9,\n    length: 2,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * International Designator (COSPAR ID): Launch number of the year.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: 1 to 999\n   * Example: 67\n   */\n\n  const intDesignatorLaunchNumber = {\n    start: 11,\n    length: 3,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * International Designator  (COSPAR ID): Piece of the launch.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: A to ZZZ\n   * Example: 'A'\n   */\n\n  const intDesignatorPieceOfLaunch = {\n    start: 14,\n    length: 3,\n    type: _TLE_DATA_TYPES._CHAR\n  };\n  /**\n   * Year when the TLE was generated (TLE epoch), last two digits.\n   *\n   * Range: 00 to 99\n   * Example: 17\n   */\n\n  const epochYear = {\n    start: 18,\n    length: 2,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Fractional day of the year when the TLE was generated (TLE epoch).\n   *\n   * Range: 1 to 365.99999999\n   * Example: 206.18396726\n   */\n\n  const epochDay = {\n    start: 20,\n    length: 12,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * First Time Derivative of the Mean Motion divided by two.  Defines how mean motion changes\n   * from day to day, so TLE propagators can still be used to make reasonable guesses when\n   * times are distant from the original TLE epoch.\n   *\n   * Units: Orbits / day ^ 2\n   * Example: 0.00001961\n   */\n\n  const firstTimeDerivative = {\n    start: 33,\n    length: 11,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Second Time Derivative of Mean Motion divided by six (decimal point assumed). Measures rate\n   * of change in the Mean Motion Dot so software can make reasonable guesses when times are\n   * distant from the original TLE epoch.\n   *\n   * Usually zero, unless the satellite is manuevering or in a decaying orbit.\n   *\n   * Units: Orbits / day ^ 3.\n   * Example: 0 ('00000-0' in the original TLE [= 0.00000 * 10 ^ 0])\n   */\n\n  const secondTimeDerivative = {\n    start: 44,\n    length: 8,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED_E\n  };\n  /**\n   * BSTAR drag term (decimal point assumed).  Estimates the effects of\n   * atmospheric drag on the satellite's motion.\n   *\n   * Units: EarthRadii ^ -1\n   * Example: 0.000036771 ('36771-4' in the original TLE [= 0.36771 * 10 ^ -4])\n   */\n\n  const bstarDrag = {\n    start: 53,\n    length: 8,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED_E\n  };\n  /**\n   * Private value - used by Air Force Space Command to reference the orbit model used to\n   * generate the TLE.  Will always be seen as zero externally (e.g. by \"us\", unless you are\n   * \"them\" - in which case, hello!).\n   *\n   * Example: 0\n   */\n\n  const orbitModel = {\n    start: 62,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * TLE element set number, incremented for each new TLE generated. 999 seems to mean the TLE\n   * has maxed out.\n   *\n   * Range: Technically 1 to 9999, though in practice the maximum number seems to be 999.\n   * Example: 999\n   */\n\n  const tleSetNumber = {\n    start: 64,\n    length: 4,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /*\n   * TLE line 1 checksum (modulo 10), for verifying the integrity of this line of the TLE.\n   *\n   * Range: 0 to 9\n   * Example: 3\n   */\n\n  const checksum1 = {\n    start: 68,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * General helper to get a piece of data from the first line of a TLE.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Object} definition From `line-1-definitions.js`\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFromLine1(tle, definition, isTLEParsed = false) {\n    const parsedTLE = isTLEParsed ? tle : parseTLE(tle);\n    return getFromTLE(parsedTLE, 1, definition);\n  }\n  /**\n   * Returns the line number from line 1.  Should always return \"1\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getLineNumber1(tle, isTLEParsed) {\n    return getFromLine1(tle, lineNumber1, isTLEParsed);\n  }\n  /**\n   * Returns the Space Catalog Number (aka NORAD Catalog Number).\n   * See https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getCatalogNumber1(tle, isTLEParsed) {\n    return getFromLine1(tle, catalogNumber1, isTLEParsed);\n  }\n  /**\n   * Returns the satellite classification.  For example, an unclassified satellite will return `U`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getClassification(tle, isTLEParsed) {\n    return getFromLine1(tle, classification, isTLEParsed);\n  }\n  /**\n   * Returns the launch year (last two digits), which makes up part of the COSPAR id\n   * (international designator).  For example, a satellite launched in 1999 will return \"99\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getIntDesignatorYear(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorYear, isTLEParsed);\n  }\n  /**\n   * Returns the launch number of the year, which makes up part of the COSPAR id\n   * (international designator).  For example, the 50th launch of the year will return \"50\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getIntDesignatorLaunchNumber(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorLaunchNumber, isTLEParsed);\n  }\n  /**\n   * Returns the piece of the launch, which makes up part of the COSPAR id (international designator).\n   * For example, the first piece of the launch will return \"A\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getIntDesignatorPieceOfLaunch(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorPieceOfLaunch, isTLEParsed);\n  }\n  /**\n   * Returns the TLE epoch year (last two digits) when the TLE was generated.  For example, a TLE\n   * generated in 2022 will return `22`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getEpochYear(tle, isTLEParsed) {\n    return getFromLine1(tle, epochYear, isTLEParsed);\n  }\n  /**\n   * Returns the TLE epoch day of the year (day of year with fractional portion of the day) when the\n   * TLE was generated.  For example, a TLE generated on January 1 will return something like\n   * `1.18396726`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getEpochDay(tle, isTLEParsed) {\n    return getFromLine1(tle, epochDay, isTLEParsed);\n  }\n  /**\n   * First Time Derivative of the Mean Motion divided by two, measured in orbits per day per day\n   * (orbits/day2). Defines how mean motion changes from day to day, so TLE propagators can still be\n   * used to make reasonable guesses when distant from the original TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getFirstTimeDerivative(tle, isTLEParsed) {\n    return getFromLine1(tle, firstTimeDerivative, isTLEParsed);\n  }\n  /**\n   * Second Time Derivative of Mean Motion divided by six, measured in orbits per day per day per day\n   * (orbits/day3). Similar to the first time derivative, it measures rate of change in the Mean\n   * Motion Dot so software can make reasonable guesses when distant from the original TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Motion and http://castor2.ca/03_Mechanics/03_TLE/Mean_Mot_Dot.html\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getSecondTimeDerivative(tle, isTLEParsed) {\n    return getFromLine1(tle, secondTimeDerivative, isTLEParsed);\n  }\n  /**\n   * BSTAR drag term. This estimates the effects of atmospheric drag on the satellite's motion.\n   * See https://en.wikipedia.org/wiki/BSTAR\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getBstarDrag(tle, isTLEParsed) {\n    return getFromLine1(tle, bstarDrag, isTLEParsed);\n  }\n  /**\n   * Private value - used by Air Force Space Command to reference the orbit model used to generate the\n   * TLE (e.g. SGP, SGP4).  Distributed TLES will always return `0` for this value.  Note that all\n   * distributed TLEs are generated with SGP4/SDP4.\n   * See https://celestrak.com/columns/v04n03/\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getOrbitModel(tle, isTLEParsed) {\n    return getFromLine1(tle, orbitModel, isTLEParsed);\n  }\n  /**\n   * TLE element set number, incremented for each new TLE generated since launch. 999 seems to mean\n   * the TLE has maxed out.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getTleSetNumber(tle, isTLEParsed) {\n    return getFromLine1(tle, tleSetNumber, isTLEParsed);\n  }\n  /**\n   * TLE line 1 checksum (modulo 10), for verifying the integrity of this line of the TLE. Note that\n   * letters, blanks, periods, and plus signs are counted as 0, while minus signs are counted as 1.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getChecksum1(tle, isTLEParsed) {\n    return getFromLine1(tle, checksum1, isTLEParsed);\n  }\n  /**\n   * Two-Line Element Set (TLE) format definitions, Line 2\n   * See https://en.wikipedia.org/wiki/Two-line_element_set and https://celestrak.com/columns/v04n03/\n   */\n\n  /* TLE line number. Will always return 2 for valid TLEs. */\n\n\n  const lineNumber2 = {\n    start: 0,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * NORAD satellite catalog number (Sputnik's rocket was 00001).  Should match the satellite\n   * number on line 1.\n   *\n   * Range: 0 to 99999\n   * Example: 25544\n   */\n\n  const catalogNumber2 = {\n    start: 2,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a\n   * prograde orbit and 90 to 180 degrees is a retrograde orbit.\n   *\n   * Units: degrees\n   * Range: 0 to 180\n   * Example: 51.6400\n   */\n\n  const inclination = {\n    start: 8,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Right ascension of the ascending node in degrees. Essentially, this is the angle of the\n   * satellite as it crosses northward (ascending) across the Earth's equator (equatorial\n   * plane).\n   *\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 208.9163\n   */\n\n  const rightAscension = {\n    start: 17,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Orbital eccentricity, decimal point assumed. All artifical Earth satellites have an\n   * eccentricity between 0 (perfect circle) and 1 (parabolic orbit).\n   *\n   * Range: 0 to 1\n   * Example: 0.0006317 (`0006317` in the original TLE)\n   */\n\n  const eccentricity = {\n    start: 26,\n    length: 7,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED\n  };\n  /**\n   * Argument of perigee. See https://en.wikipedia.org/wiki/Argument_of_perigee\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 69.9862\n   */\n\n  const perigee = {\n    start: 34,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Mean anomaly. Indicates where the satellite was located within its orbit at the time of the\n   * TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Anomaly\n   *\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 25.2906\n   */\n\n  const meanAnomaly = {\n    start: 43,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Revolutions around the Earth per day (mean motion).\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * Range: 0 to 17 (theoretically)\n   * Example: 15.54225995\n   */\n\n  const meanMotion = {\n    start: 52,\n    length: 11,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Total satellite revolutions when this TLE was generated. This number seems to roll over\n   * (e.g. 99999 -> 0).\n   *\n   * Range: 0 to 99999\n   * Example: 6766\n   */\n\n  const revNumberAtEpoch = {\n    start: 63,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /*\n   * TLE line 2 checksum (modulo 10), for verifying the integrity of this line of the TLE.\n   *\n   * Range: 0 to 9\n   * Example: 0\n   */\n\n  const checksum2 = {\n    start: 68,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * General helper to get a piece of data from the second line of a TLE.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Object} definition From `line-1-definitions.js`\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFromLine2(tle, definition, isTLEParsed = false) {\n    const parsedTLE = isTLEParsed ? tle : parseTLE(tle);\n    return getFromTLE(parsedTLE, 2, definition);\n  }\n  /**\n   * Returns the line number from line 2.  Should always return \"2\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getLineNumber2(tle, isTLEParsed) {\n    return getFromLine2(tle, lineNumber2, isTLEParsed);\n  }\n  /**\n   * Returns the line number from line 1.  Should always return \"1\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getCatalogNumber2(tle, isTLEParsed) {\n    return getFromLine2(tle, catalogNumber2, isTLEParsed);\n  }\n  /**\n   * Returns the inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a\n   * prograde orbit and 90 to 180 degrees is a retrograde orbit.\n   * See https://en.wikipedia.org/wiki/Orbital_inclination\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getInclination(tle, isTLEParsed) {\n    return getFromLine2(tle, inclination, isTLEParsed);\n  }\n  /**\n   * Returns the right ascension of the ascending node in degrees. Essentially, this is the angle of\n   * the satellite as it crosses northward (ascending) across the Earth's equator (equatorial plane).\n   * See https://en.wikipedia.org/wiki/Right_ascension_of_the_ascending_node\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getRightAscension(tle, isTLEParsed) {\n    return getFromLine2(tle, rightAscension, isTLEParsed);\n  }\n  /**\n   * Returns the orbital eccentricity. All artificial Earth satellites have an eccentricity between 0\n   * (perfect circle) and 1 (parabolic orbit).\n   * See https://en.wikipedia.org/wiki/Orbital_eccentricity\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getEccentricity(tle, isTLEParsed) {\n    return getFromLine2(tle, eccentricity, isTLEParsed);\n  }\n  /**\n   * Returns the argument of perigee.\n   * See https://en.wikipedia.org/wiki/Argument_of_perigee\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getPerigee(tle, isTLEParsed) {\n    return getFromLine2(tle, perigee, isTLEParsed);\n  }\n  /**\n   * Returns the Mean Anomaly. Indicates where the satellite was located within its orbit at the time\n   * of the TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Anomaly\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getMeanAnomaly(tle, isTLEParsed) {\n    return getFromLine2(tle, meanAnomaly, isTLEParsed);\n  }\n  /**\n   * Returns the revolutions around the Earth per day (mean motion).\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getMeanMotion(tle, isTLEParsed) {\n    return getFromLine2(tle, meanMotion, isTLEParsed);\n  }\n  /**\n   * Returns the total satellite revolutions when this TLE was generated. This number seems to roll\n   * over (e.g. 99999 -> 0).\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getRevNumberAtEpoch(tle, isTLEParsed) {\n    return getFromLine2(tle, revNumberAtEpoch, isTLEParsed);\n  }\n  /**\n   * TLE line 2 checksum (modulo 10), for verifying the integrity of this line of the TLE. Note that\n   * letters, blanks, periods, and plus signs are counted as 0, while minus signs are counted as 1.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getChecksum2(tle, isTLEParsed) {\n    return getFromLine2(tle, checksum2, isTLEParsed);\n  }\n  /**\n   * Determines COSPAR ID.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   */\n\n\n  function getCOSPAR(tle, tleIsParsed) {\n    const partialYear = getIntDesignatorYear(tle, tleIsParsed);\n\n    const fullYear = _getFullYear(partialYear);\n\n    const launchNum = getIntDesignatorLaunchNumber(tle, tleIsParsed);\n    const launchNumWithPadding = launchNum.toString().padStart(3, 0);\n    const launchPiece = getIntDesignatorPieceOfLaunch(tle, tleIsParsed);\n    return `${fullYear}-${launchNumWithPadding}${launchPiece}`;\n  }\n  /**\n   * Determines the name of a satellite, if present in the first line of a 3-line TLE.  If not found,\n   * returns \"Unknown\" by default, or the COSPAR id when fallbackToCOSPAR is true.\n   *\n   * Example:\n   * getSatelliteName(tleStr);\n   * -> 'ISS (ZARYA)'\n   *\n   * @param {String|Array} rawTLE Input TLE.\n   * @param {Boolean} fallbackToCOSPAR Returns COSPAR id when satellite name isn't found.\n   */\n\n\n  function getSatelliteName(rawTLE, fallbackToCOSPAR = false) {\n    const parsedTLE = parseTLE(rawTLE);\n    const {\n      name\n    } = parsedTLE;\n\n    if (fallbackToCOSPAR) {\n      return name || getCOSPAR(parsedTLE, true);\n    } else {\n      return name || \"Unknown\";\n    }\n  }\n  /**\n   * Determines the Unix timestamp (in ms) of a TLE epoch (the time a TLE was generated).\n   *\n   * Example:\n   * getEpochTimestamp(tleStr);\n   * -> 1500956694771\n   */\n\n\n  function getEpochTimestamp(rawTLE) {\n    const epochDay = getEpochDay(rawTLE);\n    const epochYear = getEpochYear(rawTLE);\n    return _dayOfYearToTimeStamp(epochDay, epochYear);\n  }\n  /**\n   * Determines the average amount of milliseconds in one orbit.\n   */\n\n\n  function getAverageOrbitTimeMS(tle) {\n    return parseInt(_MS_IN_A_DAY / getMeanMotion(tle), 10);\n  }\n  /**\n   * Determines the average amount of minutes in one orbit.\n   */\n\n\n  function getAverageOrbitTimeMins(tle) {\n    return getAverageOrbitTimeMS(tle) / _MS_IN_A_MINUTE;\n  }\n  /**\n   * Determines the average amount of seconds in one orbit.\n   */\n\n\n  function getAverageOrbitTimeS(tle) {\n    return getAverageOrbitTimeMS(tle) / _MS_IN_A_SECOND;\n  }\n\n  const _SAT_REC_ERRORS = {\n    _DEFAULT: \"Problematic TLE with unknown error.\",\n    1: \"Mean elements, ecc >= 1.0 or ecc < -0.001 or a < 0.95 er\",\n    2: \"Mean motion less than 0.0\",\n    3: \"Pert elements, ecc < 0.0  or  ecc > 1.0\",\n    4: \"Semi-latus rectum < 0.0\",\n    5: \"Epoch elements are sub-orbital\",\n    6: \"Satellite has decayed\"\n  };\n  let cachedSatelliteInfo = {};\n  let cachedAntemeridianCrossings = {};\n  let cachedOrbitTracks = {};\n  let cachedVisibleSatellites = {\n    slowMoving: {}\n  };\n  let cachedGroundTrack = {};\n  const caches = [cachedSatelliteInfo, cachedAntemeridianCrossings, cachedOrbitTracks, cachedVisibleSatellites, cachedGroundTrack];\n\n  function getCacheSizes() {\n    return caches.map(cache => getObjLength);\n  }\n  /**\n   * Provides a way to clear up memory for long-running apps.\n   */\n\n\n  function clearCache() {\n    cachedVisibleSatellites.slowMoving = [];\n  }\n  /**\n  \t * Determines satellite position and look angles from an earth observer.\n  \t *\n  \t * Example:\n  \t * const satInfo = getSatelliteInfo(\n  \t *   tleStr,          // Satellite TLE string or array (2 or 3 line variants).\n  \t *   1501039265000,   // Unix timestamp (ms)\n  \t *   34.243889,       // Observer latitude (degrees)\n  \t *   -116.911389,     // Observer longitude (degrees)\n  \t *   0                // Observer elevation (km)\n  \t * );\n  \t *\n  \t * ->\n  \t * {\n  \t *   // satellite compass heading from observer in degrees (0 = north, 180 = south)\n  \t *   azimuth: 294.5780478624994,\n  \t *\n  \t *   // satellite elevation from observer in degrees (90 is directly overhead)\n  \t *   elevation: 81.63903620330046,\n  \t *\n  \t *   // km distance from observer to spacecraft\n  \t *   range: 406.60211015810074,\n  \t *\n  \t *   // spacecraft altitude in km\n  \t *   height: 402.9082788620108,\n   \t *   // spacecraft latitude in degrees\n  \t *   lat: 34.45112876592785,\n   \t *   // spacecraft longitude in degrees\n  \t *   lng: -117.46176597710809,\n  \t *\n  \t *   // spacecraft velocity in km/s\n  \t *   velocity: 7.675627442183371\n  \t * }\n  \t */\n\n\n  function getSatelliteInfo(rawTLE, rawTimestamp, observerLat, observerLng, observerHeight) {\n    const timestamp = rawTimestamp || Date.now();\n    const {\n      tle\n    } = parseTLE(rawTLE);\n    const defaultObserverPosition = {\n      lat: 36.9613422,\n      lng: -122.0308,\n      height: 0.37\n    };\n    const obsLat = observerLat || defaultObserverPosition.lat;\n    const obsLng = observerLng || defaultObserverPosition.lng;\n    const obsHeight = observerHeight || defaultObserverPosition.height; // Memoization\n\n    const cacheKey = `${tle[0]}-${timestamp}-${observerLat}-${observerLng}\n-${observerHeight}`;\n\n    if (cachedSatelliteInfo[cacheKey]) {\n      return cachedSatelliteInfo[cacheKey];\n    } // Initialize a satellite record\n\n\n    const satrec = satellite_js.twoline2satrec(tle[0], tle[1]);\n\n    if (satrec.error) {\n      throw new Error(_SAT_REC_ERRORS[satrec.error] || _SAT_REC_ERRORS._DEFAULT);\n    }\n\n    const dateObj = new Date(timestamp); // Propagate SGP4.\n\n    const positionAndVelocity = satellite_js.propagate(satrec, dateObj); // The position_velocity result is a key-value pair of ECI coordinates.\n    // These are the base results from which all other coordinates are derived.\n\n    const positionEci = positionAndVelocity.position;\n    const velocityEci = positionAndVelocity.velocity; // Set the observer position (in radians).\n\n    const observerGd = {\n      latitude: _degreesToRadians(obsLat),\n      longitude: _degreesToRadians(obsLng),\n      height: obsHeight\n    }; // Get GMST for some coordinate transforms.\n    // http://en.wikipedia.org/wiki/Sidereal_time#Definition\n\n    const gmst = satellite_js.gstime(dateObj); // Get ECF, Geodetic, Look Angles, and Doppler Factor.\n\n    const positionEcf = satellite_js.eciToEcf(positionEci, gmst);\n    const positionGd = satellite_js.eciToGeodetic(positionEci, gmst);\n    const lookAngles = satellite_js.ecfToLookAngles(observerGd, positionEcf);\n    const velocityKmS = Math.sqrt(Math.pow(velocityEci.x, 2) + Math.pow(velocityEci.y, 2) + Math.pow(velocityEci.z, 2)); // Azimuth: is simply the compass heading from the observer's position.\n\n    const {\n      azimuth,\n      elevation,\n      rangeSat\n    } = lookAngles; // Geodetic coords are accessed via `longitude`, `latitude`, `height`.\n\n    const {\n      longitude,\n      latitude,\n      height\n    } = positionGd;\n    const output = {\n      lng: satellite_js.degreesLong(longitude),\n      lat: satellite_js.degreesLat(latitude),\n      elevation: _radiansToDegrees(elevation),\n      azimuth: _radiansToDegrees(azimuth),\n      range: rangeSat,\n      height,\n      velocity: velocityKmS\n    }; // Memoization\n\n    cachedSatelliteInfo[cacheKey] = output;\n    return output;\n  }\n  /**\n   * Determines if the last antemeridian crossing has been cached.  If it has, the time (in ms)\n   * is returned, otherwise it returns false.\n   */\n\n\n  function getCachedLastAntemeridianCrossingTimeMS(tleObj, timeMS) {\n    const {\n      tle\n    } = tleObj;\n    const orbitLengthMS = getAverageOrbitTimeMins(tle) * 60 * 1000;\n    const tleStr = tle[0].substr(0, 30);\n    const cachedCrossingTimes = cachedAntemeridianCrossings[tleStr];\n    if (!cachedCrossingTimes) return false;\n    if (cachedCrossingTimes === -1) return cachedCrossingTimes;\n    const cachedTime = cachedCrossingTimes.filter(val => {\n      if (typeof val === \"object\" && val.tle === tle) return -1;\n      const diff = timeMS - val;\n      const isDiffPositive = diff > 0;\n      const isWithinOrbit = isDiffPositive && diff < orbitLengthMS;\n      return isWithinOrbit;\n    });\n    return cachedTime[0] || false;\n  }\n  /**\n   * Determines the last time the satellite crossed the antemeridian.  For mapping convenience\n   * and to avoid headaches, we want to avoid plotting ground tracks that cross the antemeridian.\n   */\n\n\n  function getLastAntemeridianCrossingTimeMS(tle, timeMS) {\n    const parsedTLE = parseTLE(tle);\n    const {\n      tle: tleArr\n    } = parsedTLE;\n    const cachedVal = getCachedLastAntemeridianCrossingTimeMS(parsedTLE, timeMS);\n\n    if (cachedVal) {\n      return cachedVal;\n    }\n\n    const time = timeMS || Date.now();\n    let step = 1000 * 60 * 10;\n    let curLngLat = [];\n    let lastLngLat = [];\n    let curTimeMS = time;\n    let didCrossAntemeridian = false;\n    let tries = 0;\n    let isDone = false;\n    const maxTries = 1000;\n\n    while (!isDone) {\n      curLngLat = getLngLat(tleArr, curTimeMS);\n      const [curLng, curLat] = curLngLat;\n      didCrossAntemeridian = _crossesAntemeridian(lastLngLat[0], curLng);\n\n      if (didCrossAntemeridian) {\n        // Back up a bit, then keep halving the step increment till we get close enough.\n        curTimeMS += step;\n        step = step > 20000 ? 20000 : step / 2;\n      } else {\n        curTimeMS -= step;\n        lastLngLat = curLngLat;\n      }\n\n      isDone = step < 500 || tries >= maxTries;\n      tries++;\n    }\n\n    const couldNotFindCrossing = tries - 1 === maxTries;\n    const crossingTime = couldNotFindCrossing ? -1 : parseInt(curTimeMS, 10);\n    const tleStr = tleArr[0];\n\n    if (!cachedAntemeridianCrossings[tleStr]) {\n      cachedAntemeridianCrossings[tleStr] = [];\n    }\n\n    if (couldNotFindCrossing) {\n      cachedAntemeridianCrossings[tleStr] = -1;\n    } else {\n      cachedAntemeridianCrossings[tleStr].push(crossingTime);\n    }\n\n    return crossingTime;\n  }\n  /**\n   * Determines current satellite position, or position at time of timestamp (optional).\n   *\n   * @param {Array|String} tle\n   * @param {Number} optionalTimestamp Unix timestamp in milliseconds.\n   */\n\n\n  function getLatLngObj(tle, optionalTimestamp = Date.now()) {\n    const {\n      lat,\n      lng\n    } = getSatelliteInfo(tle, optionalTimestamp);\n    return {\n      lat,\n      lng\n    };\n  }\n  /**\n   * Determines current satellite position, or position at time of timestamp (optional).\n   *\n   * @param {Array|String} tle\n   * @param {Number} optionalTimestamp Unix timestamp in milliseconds.\n   */\n\n\n  function getLngLat(tle, optionalTimestamp = Date.now()) {\n    const {\n      lat,\n      lng\n    } = getSatelliteInfo(tle, optionalTimestamp);\n    return [lng, lat];\n  }\n  /**\n   * Determines the position of the satellite at the time the TLE was generated.\n   *\n   * @param {Array|String} tle\n   */\n\n\n  function getLngLatAtEpoch(tle) {\n    return getLngLat(tle, getEpochTimestamp(tle));\n  } // TODO: cache geosync and erroring satellites and don't recompute on next pass.\n\n\n  function getVisibleSatellites({\n    observerLat,\n    observerLng,\n    observerHeight = 0,\n    tles = [],\n    elevationThreshold = 0,\n    timestampMS = Date.now()\n  }) {\n    return tles.reduce((visibleSats, tleArr, index) => {\n      // Don't waste time reprocessing geosync.\n      const cacheKey = tleArr[1];\n      const cachedVal = cachedVisibleSatellites.slowMoving[cacheKey];\n\n      if (cachedVal) {\n        const {\n          info\n        } = cachedVal;\n        const {\n          elevation: cachedElevation\n        } = info;\n        return cachedElevation >= elevationThreshold ? visibleSats.concat(cachedVal) : visibleSats;\n      }\n\n      let info;\n\n      try {\n        info = getSatelliteInfo(tleArr, timestampMS, observerLat, observerLng, observerHeight);\n      } catch (e) {\n        // Don't worry about decayed sats, just move on.\n        // TODO cache error\n        return visibleSats;\n      }\n\n      const {\n        elevation,\n        velocity,\n        range\n      } = info;\n      const isSlowMoving = velocity / range < 0.001;\n\n      if (isSlowMoving) {\n        cachedVisibleSatellites.slowMoving[cacheKey] = {\n          tleArr,\n          info\n        };\n      }\n\n      return elevation >= elevationThreshold ? visibleSats.concat({\n        tleArr,\n        info\n      }) : visibleSats;\n    }, []);\n  }\n\n  function* getNextPosition(tleArr, startTimeMS, stepMS) {\n    let curTimeMS = startTimeMS - stepMS;\n\n    while (true) {\n      curTimeMS += stepMS;\n      yield {\n        curTimeMS,\n        lngLat: getLngLat(tleArr, curTimeMS)\n      };\n    }\n  }\n\n  function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  /**\n   * Generates an array of lng/lat pairs representing a ground track (orbit track), starting\n   * from startTimeMS and continuing until just before crossing the antemeridian, which is considered the end\n   * of the orbit for convenience.\n   *\n   * Consider pairing this with getLastAntemeridianCrossingTimeMS() to create a full orbit path (see usage\n   * in getGroundTracks()).\n   */\n\n\n  function getOrbitTrack({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    sleepMS = 0,\n    jobChunkSize = 1000,\n    maxTimeMS = 6000000,\n    isLngLatFormat = true\n  }) {\n    return new Promise(async (resolve, reject) => {\n      const {\n        tle: tleArr\n      } = parseTLE(tle);\n      const startS = (startTimeMS / 1000).toFixed();\n      const cacheKey = `${tleArr[0]}-${startS}-${stepMS}-${isLngLatFormat}`;\n\n      if (cachedOrbitTracks[cacheKey]) {\n        resolve(cachedOrbitTracks[cacheKey]);\n        return;\n      }\n\n      const generator = getNextPosition(tleArr, startTimeMS, stepMS);\n      let step = 0;\n      let isDone = false;\n      let coords = [];\n      let lastLng;\n\n      while (!isDone) {\n        const {\n          curTimeMS,\n          lngLat\n        } = generator.next().value;\n        const [curLng, curLat] = lngLat;\n\n        const doesCrossAntemeridian = _crossesAntemeridian(lastLng, curLng);\n\n        const doesExceedTime = maxTimeMS && curTimeMS - startTimeMS > maxTimeMS;\n        isDone = doesCrossAntemeridian || doesExceedTime;\n\n        if (isLngLatFormat) {\n          coords.push(lngLat);\n        } else {\n          coords.push([curLat, curLng]);\n        }\n\n        if (sleepMS && step % jobChunkSize === 0) {\n          // Chunk is processed, so cool off a bit.\n          await sleep(sleepMS);\n        }\n\n        lastLng = curLng;\n        step++;\n      }\n\n      cachedOrbitTracks[cacheKey] = coords;\n      resolve(coords);\n    });\n  }\n  /**\n   *\n   */\n\n\n  function getOrbitTrackSync({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    maxTimeMS = 6000000,\n    isLngLatFormat = true\n  }) {\n    const {\n      tle: tleArr\n    } = parseTLE(tle);\n    const startS = (startTimeMS / 1000).toFixed();\n    const cacheKey = `${tleArr[0]}-${startS}-${stepMS}-${isLngLatFormat}`;\n\n    if (cachedOrbitTracks[cacheKey]) {\n      return cachedOrbitTracks[cacheKey];\n    }\n\n    let isDone = false;\n    let coords = [];\n    let lastLng;\n    let curTimeMS = startTimeMS;\n\n    while (!isDone) {\n      const curLngLat = getLngLat(tleArr, curTimeMS);\n      const [curLng, curLat] = curLngLat;\n\n      const doesCrossAntemeridian = _crossesAntemeridian(lastLng, curLng);\n\n      const doesExceedTime = maxTimeMS && curTimeMS - startTimeMS > maxTimeMS;\n      isDone = doesCrossAntemeridian || doesExceedTime;\n\n      if (isLngLatFormat) {\n        coords.push(curLngLat);\n      } else {\n        coords.push([curLat, curLng]);\n      }\n\n      lastLng = curLng;\n      curTimeMS += stepMS;\n    }\n\n    cachedOrbitTracks[cacheKey] = coords;\n    return coords;\n  }\n  /**\n   * Calculates three orbit arrays of latitude/longitude pairs.\n   * TODO: just calculate future orbits\n   *\n   * @param {Array|String} options.tle\n   * @param {Number} startTimeMS Unix timestamp in milliseconds.\n   * @param {Number} stepMS Time in milliseconds between points on the ground track.\n   * @param {Boolean} isLngLatFormat Formats coords in [lng, lat] order when true, [lat, lng] when false.\n   * \n   *\n   * Example:\n   * const threeOrbitsArr = await getGroundTracks({ tle: tleStr });\n   * ->\n   * [\n   *   // previous orbit\n   *   [\n   *     [ 45.85524291891481, -179.93297540317567 ],\n   *     ...\n   *   ],\n   *\n   *   // current orbit\n   *   [\n   *     [ 51.26165992503701, -179.9398612198045 ],\n   *     ...\n   *   ],\n   *\n   *   // next orbit\n   *   [\n   *     [ 51.0273714070371, -179.9190165549038 ],\n   *     ...\n   *   ]\n   * ]\n   */\n\n\n  function getGroundTracks({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    isLngLatFormat = true\n  }) {\n    return new Promise(async (resolve, reject) => {\n      const parsedTLE = parseTLE(tle);\n      const orbitTimeMS = getAverageOrbitTimeMS(parsedTLE);\n      const curOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, startTimeMS);\n      const foundCrossing = curOrbitStartMS !== -1;\n\n      if (!foundCrossing) {\n        // Geosync or unusual orbit, so just return a partial orbit track.\n        const partialGroundTrack = await getOrbitTrack({\n          tle: parsedTLE,\n          startTimeMS,\n          stepMS: _MS_IN_A_MINUTE,\n          maxTimeMS: _MS_IN_A_DAY / 4,\n          isLngLatFormat\n        });\n        resolve([partialGroundTrack]);\n        return;\n      }\n\n      const lastOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, // TODO: fix this magic math\n      curOrbitStartMS - 10000);\n      const nextOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, // TODO: fix this magic math\n      curOrbitStartMS + orbitTimeMS + 1000 * 60 * 30);\n      const groundTrackPromises = [getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: lastOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      }), getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: curOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      }), getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: nextOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      })];\n      const threeOrbitTracks = await Promise.all(groundTrackPromises);\n      resolve(threeOrbitTracks);\n    });\n  }\n  /**\n   * Calculates three orbit arrays of latitude/longitude pairs.\n   *\n   * Example:\n   * const threeOrbitsArr = getGroundTrackSync({ tle: tleStr });\n   * ->\n   * [\n   *   // previous orbit\n   *   [\n   *     [ 45.85524291891481, -179.93297540317567 ],\n   *     ...\n   *   ],\n   *\n   *   // current orbit\n   *   [\n   *     [ 51.26165992503701, -179.9398612198045 ],\n   *     ...\n   *   ],\n   *\n   *   // next orbit\n   *   [\n   *     [ 51.0273714070371, -179.9190165549038 ],\n   *     ...\n   *   ]\n   * ]\n   */\n\n\n  function getGroundTracksSync({\n    tle,\n    stepMS = 1000,\n    optionalTimeMS = Date.now(),\n    isLngLatFormat = true\n  }) {\n    const parsedTLE = parseTLE(tle);\n    const {\n      tle: tleArr\n    } = parsedTLE;\n    const orbitTimeMS = getAverageOrbitTimeMS(tleArr);\n    const curOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, optionalTimeMS);\n    const foundCrossing = curOrbitStartMS !== -1;\n\n    if (!foundCrossing) {\n      // Geosync or unusual orbit, so just return a partial orbit track.\n      const partialGroundTrack = getOrbitTrackSync({\n        tle: parsedTLE,\n        startTimeMS: timeMS,\n        stepMS: _MS_IN_A_MINUTE,\n        maxTimeMS: _MS_IN_A_DAY / 4\n      });\n      return partialGroundTrack;\n    }\n\n    const lastOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, curOrbitStartMS - 10000);\n    const nextOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, curOrbitStartMS + orbitTimeMS + 1000 * 60 * 30);\n    const orbitStartTimes = [lastOrbitStartMS, curOrbitStartMS, nextOrbitStartMS];\n    const orbitLatLons = orbitStartTimes.map(orbitStartMS => {\n      return getOrbitTrackSync({\n        tle: parsedTLE,\n        startTimeMS: orbitStartMS,\n        stepMS,\n        isLngLatFormat\n      });\n    });\n    return orbitLatLons;\n  }\n  /**\n   * Determes the compass bearing from the perspective of the satellite.  Useful for 3D / pitched\n   * map perspectives.\n   *\n   * TODO: a bit buggy at extreme parts of orbits, where latitude hardly changes.\n   */\n\n\n  function getSatBearing(tle, customTimeMS) {\n    const parsedTLE = this.parseTLE(tle);\n    const timeMS = customTimeMS || Date.now();\n    const latLon1 = this.getLatLonArr(parsedTLE.arr, timeMS);\n    const latLon2 = this.getLatLonArr(parsedTLE.arr, timeMS + 10000);\n\n    const doesCrossAntemeridian = _crossesAntemeridian(latLon1[1], latLon2[1]);\n\n    if (doesCrossAntemeridian) {\n      // TODO: fix\n      return {}; // return this.getSatBearing(tle, customTimeMS + 10000);\n    }\n\n    const lat1 = _degreesToRadians(latLon1[0]);\n\n    const lat2 = _degreesToRadians(latLon2[0]);\n\n    const lon1 = _degreesToRadians(latLon1[1]);\n\n    const lon2 = _degreesToRadians(latLon2[1]);\n\n    const NS = lat1 >= lat2 ? \"S\" : \"N\";\n    const EW = lon1 >= lon2 ? \"W\" : \"E\";\n    const y = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    const degrees = _radiansToDegrees(Math.atan2(y, x));\n\n    return {\n      degrees,\n      compass: `${NS}${EW}`\n    };\n  }\n\n  exports.clearCache = clearCache;\n  exports.computeChecksum = computeChecksum;\n  exports.getAverageOrbitTimeMS = getAverageOrbitTimeMS;\n  exports.getAverageOrbitTimeMins = getAverageOrbitTimeMins;\n  exports.getAverageOrbitTimeS = getAverageOrbitTimeS;\n  exports.getBstarDrag = getBstarDrag;\n  exports.getCOSPAR = getCOSPAR;\n  exports.getCacheSizes = getCacheSizes;\n  exports.getCatalogNumber = getCatalogNumber1;\n  exports.getCatalogNumber1 = getCatalogNumber1;\n  exports.getCatalogNumber2 = getCatalogNumber2;\n  exports.getChecksum1 = getChecksum1;\n  exports.getChecksum2 = getChecksum2;\n  exports.getClassification = getClassification;\n  exports.getEccentricity = getEccentricity;\n  exports.getEpochDay = getEpochDay;\n  exports.getEpochTimestamp = getEpochTimestamp;\n  exports.getEpochYear = getEpochYear;\n  exports.getFirstTimeDerivative = getFirstTimeDerivative;\n  exports.getGroundTracks = getGroundTracks;\n  exports.getGroundTracksSync = getGroundTracksSync;\n  exports.getInclination = getInclination;\n  exports.getIntDesignatorLaunchNumber = getIntDesignatorLaunchNumber;\n  exports.getIntDesignatorPieceOfLaunch = getIntDesignatorPieceOfLaunch;\n  exports.getIntDesignatorYear = getIntDesignatorYear;\n  exports.getLastAntemeridianCrossingTimeMS = getLastAntemeridianCrossingTimeMS;\n  exports.getLatLngObj = getLatLngObj;\n  exports.getLineNumber1 = getLineNumber1;\n  exports.getLineNumber2 = getLineNumber2;\n  exports.getLngLatAtEpoch = getLngLatAtEpoch;\n  exports.getMeanAnomaly = getMeanAnomaly;\n  exports.getMeanMotion = getMeanMotion;\n  exports.getOrbitModel = getOrbitModel;\n  exports.getOrbitTrack = getOrbitTrack;\n  exports.getOrbitTrackSync = getOrbitTrackSync;\n  exports.getPerigee = getPerigee;\n  exports.getRevNumberAtEpoch = getRevNumberAtEpoch;\n  exports.getRightAscension = getRightAscension;\n  exports.getSatBearing = getSatBearing;\n  exports.getSatelliteInfo = getSatelliteInfo;\n  exports.getSatelliteName = getSatelliteName;\n  exports.getSecondTimeDerivative = getSecondTimeDerivative;\n  exports.getTleSetNumber = getTleSetNumber;\n  exports.getVisibleSatellites = getVisibleSatellites;\n  exports.isValidTLE = isValidTLE;\n  exports.parseTLE = parseTLE;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["C:/Users/Md. Mehrab Haque/Desktop/satellight/node_modules/tle.js/dist/tlejs.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","tlejs","satellite","satellite_js","_MS_IN_A_DAY","_MS_IN_A_SECOND","_MS_IN_A_MINUTE","_TLE_DATA_TYPES","_INT","Symbol","_FLOAT","_CHAR","_DECIMAL_ASSUMED","_DECIMAL_ASSUMED_E","_DATA_TYPES","_ARRAY","_STRING","_OBJECT","_DATE","_NAN","getType","input","type","Array","isArray","Date","Number","isNaN","_isPositive","num","_getDigitCount","absVal","Math","abs","toString","length","_toLeadingDecimal","numDigits","zeroes","repeat","parseFloat","_decimalAssumedEToFloat","str","numWithAssumedLeadingDecimal","substr","leadingDecimalPoints","parseInt","float","pow","toPrecision","_dayOfYearToTimeStamp","dayOfYear","year","getFullYear","yearStart","yearStartMS","getTime","floor","_radiansToDegrees","radians","PI","_degreesToRadians","degrees","_crossesAntemeridian","longitude1","longitude2","isLong1Positive","isLong2Positive","haveSameSigns","isNearAntemeridian","_getFullYear","twoDigitYear","twoDigitYearInt","getFromTLE","parsedTLE","lineNumber","definition","name","tle","line","start","val","output","trim","_ERRORS","_TYPE","context","expected","got","join","_NOT_PARSED_OBJECT","isTLEObj","obj","tleCache","acceptedTLETypes","parseTLE","sourceTLE","tleArray","alreadyParsed","isUnexpectedObject","Error","cacheKey","includes","split","from","slice","map","computeChecksum","tleLineStr","charArr","splice","checksum","reduce","sum","parsedVal","parsedSum","isInteger","lineNumberIsValid","tleObj","checksumIsValid","tleLine","checksumInTLE","computedChecksum","isValidTLE","rawTLE","e","line1NumberIsValid","line2NumberIsValid","line1ChecksumIsValid","line2ChecksumIsValid","lineNumber1","catalogNumber1","classification","intDesignatorYear","intDesignatorLaunchNumber","intDesignatorPieceOfLaunch","epochYear","epochDay","firstTimeDerivative","secondTimeDerivative","bstarDrag","orbitModel","tleSetNumber","checksum1","getFromLine1","isTLEParsed","getLineNumber1","getCatalogNumber1","getClassification","getIntDesignatorYear","getIntDesignatorLaunchNumber","getIntDesignatorPieceOfLaunch","getEpochYear","getEpochDay","getFirstTimeDerivative","getSecondTimeDerivative","getBstarDrag","getOrbitModel","getTleSetNumber","getChecksum1","lineNumber2","catalogNumber2","inclination","rightAscension","eccentricity","perigee","meanAnomaly","meanMotion","revNumberAtEpoch","checksum2","getFromLine2","getLineNumber2","getCatalogNumber2","getInclination","getRightAscension","getEccentricity","getPerigee","getMeanAnomaly","getMeanMotion","getRevNumberAtEpoch","getChecksum2","getCOSPAR","tleIsParsed","partialYear","fullYear","launchNum","launchNumWithPadding","padStart","launchPiece","getSatelliteName","fallbackToCOSPAR","getEpochTimestamp","getAverageOrbitTimeMS","getAverageOrbitTimeMins","getAverageOrbitTimeS","_SAT_REC_ERRORS","_DEFAULT","cachedSatelliteInfo","cachedAntemeridianCrossings","cachedOrbitTracks","cachedVisibleSatellites","slowMoving","cachedGroundTrack","caches","getCacheSizes","cache","getObjLength","clearCache","getSatelliteInfo","rawTimestamp","observerLat","observerLng","observerHeight","timestamp","now","defaultObserverPosition","lat","lng","height","obsLat","obsLng","obsHeight","satrec","twoline2satrec","error","dateObj","positionAndVelocity","propagate","positionEci","position","velocityEci","velocity","observerGd","latitude","longitude","gmst","gstime","positionEcf","eciToEcf","positionGd","eciToGeodetic","lookAngles","ecfToLookAngles","velocityKmS","sqrt","x","y","z","azimuth","elevation","rangeSat","degreesLong","degreesLat","range","getCachedLastAntemeridianCrossingTimeMS","timeMS","orbitLengthMS","tleStr","cachedCrossingTimes","cachedTime","filter","diff","isDiffPositive","isWithinOrbit","getLastAntemeridianCrossingTimeMS","tleArr","cachedVal","time","step","curLngLat","lastLngLat","curTimeMS","didCrossAntemeridian","tries","isDone","maxTries","getLngLat","curLng","curLat","couldNotFindCrossing","crossingTime","push","getLatLngObj","optionalTimestamp","getLngLatAtEpoch","getVisibleSatellites","tles","elevationThreshold","timestampMS","visibleSats","index","info","cachedElevation","concat","isSlowMoving","getNextPosition","startTimeMS","stepMS","lngLat","sleep","ms","Promise","resolve","setTimeout","getOrbitTrack","sleepMS","jobChunkSize","maxTimeMS","isLngLatFormat","reject","startS","toFixed","generator","coords","lastLng","next","value","doesCrossAntemeridian","doesExceedTime","getOrbitTrackSync","getGroundTracks","orbitTimeMS","curOrbitStartMS","foundCrossing","partialGroundTrack","lastOrbitStartMS","nextOrbitStartMS","groundTrackPromises","threeOrbitTracks","all","getGroundTracksSync","optionalTimeMS","orbitStartTimes","orbitLatLons","orbitStartMS","getSatBearing","customTimeMS","latLon1","getLatLonArr","arr","latLon2","lat1","lat2","lon1","lon2","NS","EW","sin","cos","atan2","compass","getCatalogNumber","Object","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('satellite.js')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'satellite.js'], factory) :\n  (global = global || self, factory(global.tlejs = {}, global.satellite));\n}(this, (function (exports, satellite_js) { 'use strict';\n\n  const _MS_IN_A_DAY = 86400000;\n  const _MS_IN_A_SECOND = 1000;\n  const _MS_IN_A_MINUTE = 60000; // Data formats for TLE orbital elements.\n\n  const _TLE_DATA_TYPES = {\n    _INT: Symbol(),\n    _FLOAT: Symbol(),\n    _CHAR: Symbol(),\n    _DECIMAL_ASSUMED: Symbol(),\n    // 12345   -> 0.12345\n    _DECIMAL_ASSUMED_E: Symbol() // 12345-2 -> 0.0012345\n\n  };\n  const _DATA_TYPES = {\n    _ARRAY: \"array\",\n    _STRING: \"string\",\n    _OBJECT: \"object\",\n    _DATE: \"date\",\n    _NAN: \"NaN\"\n  };\n\n  /**\n   * General helper that provides more useful info than JavaScript's built-in \"typeof\" operator.\n   *\n   * Example:\n   * getType([]);\n   * -> 'array'\n   */\n\n  function getType(input) {\n    const type = typeof input;\n\n    if (Array.isArray(input)) {\n      return _DATA_TYPES._ARRAY;\n    }\n\n    if (input instanceof Date) {\n      return _DATA_TYPES._DATE;\n    }\n\n    if (Number.isNaN(input)) {\n      return _DATA_TYPES._NAN;\n    }\n\n    return type;\n  }\n  /**\n   * Determines if a number is positive.\n   */\n\n  const _isPositive = num => num >= 0;\n  /**\n   * Determines the amount of digits in a number.  Used for converting a TLE's \"leading decimal\n   * assumed\" notation.\n   *\n   * Example:\n   * getDigitCount(12345);\n   * -> 5\n   */\n\n  const _getDigitCount = num => {\n    const absVal = Math.abs(num);\n    return absVal.toString().length;\n  };\n  /**\n   * Converts a TLE's \"leading decimal assumed\" notation to a float representation.\n   *\n   * Example:\n   * toLeadingDecimal(12345);\n   * -> 0.12345\n   */\n\n  const _toLeadingDecimal = num => {\n    const numDigits = _getDigitCount(num);\n\n    const zeroes = \"0\".repeat(numDigits - 1);\n    return parseFloat(num * `0.${zeroes}1`);\n  };\n  /**\n   * Converts a TLE's \"leading decimal assumed\" notation with leading zeroes to a float\n   * representation.\n   *\n   * Example:\n   * decimalAssumedEToFloat('12345-4');\n   * -> 0.000012345\n   */\n\n  const _decimalAssumedEToFloat = str => {\n    const numWithAssumedLeadingDecimal = str.substr(0, str.length - 2);\n\n    const num = _toLeadingDecimal(numWithAssumedLeadingDecimal);\n\n    const leadingDecimalPoints = parseInt(str.substr(str.length - 2, 2), 10);\n    const float = num * Math.pow(10, leadingDecimalPoints);\n    return parseFloat(float.toPrecision(5));\n  };\n  /**\n   * Converts a fractional day of the year to a timestamp.  Used for parsing the TLE epoch.\n   */\n\n  const _dayOfYearToTimeStamp = (dayOfYear, year = new Date().getFullYear()) => {\n    const yearStart = new Date(`1/1/${year} 0:0:0 Z`);\n    const yearStartMS = yearStart.getTime();\n    return Math.floor(yearStartMS + (dayOfYear - 1) * _MS_IN_A_DAY);\n  };\n  /**\n   * Converts radians (0 to 2π) to degrees (0 to 360).\n   */\n\n  const _radiansToDegrees = radians => radians * (180 / Math.PI);\n  /**\n   * Converts degrees (0 to 360) to radians (0 to 2π).\n   */\n\n  const _degreesToRadians = degrees => degrees * (Math.PI / 180);\n  /**\n   * Determines if a pair of longitude points crosses over the antemeridian, which is a\n   * pain point for mapping software.\n   */\n\n  const _crossesAntemeridian = (longitude1, longitude2) => {\n    if (!longitude1 || !longitude2) return false;\n\n    const isLong1Positive = _isPositive(longitude1);\n\n    const isLong2Positive = _isPositive(longitude2);\n\n    const haveSameSigns = isLong1Positive === isLong2Positive;\n    if (haveSameSigns) return false; // Signs don't match, so check if we're reasonably near the antemeridian (just to be sure it's\n    // not the prime meridian).\n\n    const isNearAntemeridian = Math.abs(longitude1) > 100;\n    return isNearAntemeridian;\n  };\n  /**\n   * Note: TLEs have a year 2000 style problem in 2057, because they only represent years in 2\n   * characters.  This function doesn't account for that problem.\n   *\n   * Example:\n   * _getFullYear(98);\n   * -> 1998\n   *\n   * @param {Number} twoDigitYear\n   */\n\n  function _getFullYear(twoDigitYear) {\n    const twoDigitYearInt = parseInt(twoDigitYear, 10);\n    return twoDigitYearInt < 100 && twoDigitYearInt > 56 ? twoDigitYearInt + 1900 : twoDigitYearInt + 2000;\n  }\n  /**\n   * Gets a piece of data directly from a TLE line string, and attempts to parse it based on\n   * data format.\n   *\n   * @param {Object} parsedTLE\n   * @param {(1|2)} lineNumber TLE line number.\n   * @param {Object} definition From line-1-definitions or line-2-definitions.\n   */\n\n  function getFromTLE(parsedTLE, lineNumber, definition) {\n    const {\n      name,\n      tle\n    } = parsedTLE;\n    const line = lineNumber === 1 ? tle[0] : tle[1];\n    const {\n      start,\n      length,\n      type\n    } = definition;\n    const val = line.substr(start, length);\n    let output;\n\n    switch (type) {\n      case _TLE_DATA_TYPES._INT:\n        output = parseInt(val, 10);\n        break;\n\n      case _TLE_DATA_TYPES._FLOAT:\n        output = parseFloat(val);\n        break;\n\n      case _TLE_DATA_TYPES._DECIMAL_ASSUMED:\n        output = parseFloat(`0.${val}`);\n        break;\n\n      case _TLE_DATA_TYPES._DECIMAL_ASSUMED_E:\n        output = _decimalAssumedEToFloat(val);\n        break;\n\n      case _TLE_DATA_TYPES._CHAR:\n      default:\n        output = val.trim();\n        break;\n    }\n\n    return output;\n  }\n\n  const _ERRORS = {\n    _TYPE: (context = \"\", expected = [], got = \"\") => `${context} must be of type [${expected.join(\", \")}], but got ${got}.`,\n    _NOT_PARSED_OBJECT: `Input object is malformed (should have name and tle properties).`\n  };\n  function isTLEObj(obj) {\n    return typeof obj === _DATA_TYPES._OBJECT && obj.name && obj.tle && getType(obj.tle) === _DATA_TYPES._ARRAY && obj.tle.length === 2;\n  } // For TLE parsing memoization.\n\n  const tleCache = {};\n  /**\n   * Converts string and array TLE formats into a \"parsed\" TLE in a consistent object format.\n   * Accepts 2 and 3-line (with satellite name) TLE variants in string (\\n-delimited) and array\n   * forms.\n   *\n   * Example:\n   * parseTLE(`ISS (ZARYA)\n   * 1 25544U 98067A   19285.67257269  .00001247  00000-0  29690-4 0  9993\n   * 2 25544  51.6439 138.6866 0007415 141.2524 326.3533 15.50194187193485`);\n   * ->\n   * {\n   *   name: 'ISS (ZARYA)',\n   *   tle: [\n   *     '1 25544U 98067A   19285.67257269  .00001247  00000-0  29690-4 0  9993',\n   *     '2 25544  51.6439 138.6866 0007415 141.2524 326.3533 15.50194187193485'\n   *   ]\n   * }\n   */\n\n  const acceptedTLETypes = [_DATA_TYPES._ARRAY, _DATA_TYPES._STRING, _DATA_TYPES._OBJECT];\n  function parseTLE(sourceTLE) {\n    const type = getType(sourceTLE);\n    const output = {};\n    let tleArray = [];\n    const alreadyParsed = isTLEObj(sourceTLE);\n\n    if (alreadyParsed) {\n      // This TLE has already been parsed, so there's nothing left to do.\n      return sourceTLE;\n    }\n\n    const isUnexpectedObject = !alreadyParsed && type === _DATA_TYPES._OBJECT;\n\n    if (isUnexpectedObject) {\n      // TLE is in an unexpected object format.\n      throw new Error(_ERRORS._NOT_PARSED_OBJECT);\n    } // Note: only strings and arrays will make it past this point.\n    // Check if the TLE exists in the cache.\n\n\n    const cacheKey = type === _DATA_TYPES._ARRAY ? sourceTLE[0] : sourceTLE;\n\n    if (tleCache[cacheKey]) {\n      return tleCache[cacheKey];\n    }\n\n    if (!acceptedTLETypes.includes(type)) {\n      throw new Error(_ERRORS._TYPE(\"Source TLE\", acceptedTLETypes, type));\n    } // Convert to array.\n\n\n    if (type === _DATA_TYPES._STRING) {\n      tleArray = sourceTLE.split(\"\\n\");\n    } else if (type === _DATA_TYPES._ARRAY) {\n      // Already an array, so make a copy so we don't mutate the input.\n      tleArray = Array.from(sourceTLE);\n    } // 3-line variant: remove name from array for consistency.\n\n\n    if (tleArray.length === 3) {\n      const name = tleArray[0].trim();\n      tleArray = tleArray.slice(1); // Preserve original name string for use in the getSatelliteName() getter.\n\n      output.name = name;\n    }\n\n    output.tle = tleArray.map(line => line.trim()); // Update cache.\n\n    tleCache[cacheKey] = output;\n    return output;\n  }\n  /**\n   * Determines the checksum for a single line of a TLE.\n   *\n   * Checksum = modulo 10 of sum of all numbers (including line number) + 1 for each negative\n   * sign (-).  Everything else is ignored.\n   */\n\n  function computeChecksum(tleLineStr) {\n    const charArr = tleLineStr.split(\"\"); // Remove trailing checksum.\n\n    charArr.splice(charArr.length - 1, 1);\n\n    if (charArr.length === 0) {\n      throw new Error(\"Character array empty!\", tleLineStr);\n    }\n\n    const checksum = charArr.reduce((sum, val) => {\n      const parsedVal = parseInt(val, 10);\n      const parsedSum = parseInt(sum, 10);\n\n      if (Number.isInteger(parsedVal)) {\n        return parsedSum + parsedVal;\n      }\n\n      if (val === \"-\") {\n        return parsedSum + 1;\n      }\n\n      return parsedSum;\n    });\n    return checksum % 10;\n  }\n  function lineNumberIsValid(tleObj, lineNumber) {\n    const {\n      tle\n    } = tleObj;\n    return lineNumber === parseInt(tle[lineNumber - 1][0], 10);\n  }\n  function checksumIsValid(tleObj, lineNumber) {\n    const {\n      tle\n    } = tleObj;\n    const tleLine = tle[lineNumber - 1];\n    const checksumInTLE = parseInt(tleLine[tleLine.length - 1], 10);\n    const computedChecksum = computeChecksum(tle[lineNumber - 1]);\n    return computedChecksum === checksumInTLE;\n  }\n  /**\n   * Determines if a TLE is structurally valid.\n   */\n\n  function isValidTLE(rawTLE) {\n    let tleObj;\n\n    try {\n      tleObj = parseTLE(rawTLE);\n    } catch (e) {\n      return false;\n    } // Line number checks.\n\n\n    const line1NumberIsValid = lineNumberIsValid(tleObj, 1);\n    const line2NumberIsValid = lineNumberIsValid(tleObj, 2);\n\n    if (!line1NumberIsValid || !line2NumberIsValid) {\n      return false;\n    } // Checksums\n\n\n    const line1ChecksumIsValid = checksumIsValid(tleObj, 1);\n    const line2ChecksumIsValid = checksumIsValid(tleObj, 2);\n\n    if (!line1ChecksumIsValid || !line2ChecksumIsValid) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Two-Line Element Set (TLE) format definitions, Line 1\n   * See https://en.wikipedia.org/wiki/Two-line_element_set and https://celestrak.com/columns/v04n03/\n   */\n\n  /* TLE line number. Will always return 1 for valid TLEs. */\n\n  const lineNumber1 = {\n    start: 0,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * NORAD satellite catalog number (e.g. Sputnik's rocket was number 00001).\n   * See https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n   *\n   * Range: 0 to 99999\n   * Example: 25544\n   */\n\n  const catalogNumber1 = {\n    start: 2,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Satellite classification.\n   * 'U' = unclassified\n   * 'C' = classified\n   * 'S' = secret\n   *\n   * Example: 'U'\n   */\n\n  const classification = {\n    start: 7,\n    length: 1,\n    type: _TLE_DATA_TYPES._CHAR\n  };\n  /**\n   * International Designator (COSPAR ID): Last 2 digits of launch year.\n   * 57 to 99 = 1900s, 00-56 = 2000s\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: 00 to 99\n   * Example: 98\n   */\n\n  const intDesignatorYear = {\n    start: 9,\n    length: 2,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * International Designator (COSPAR ID): Launch number of the year.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: 1 to 999\n   * Example: 67\n   */\n\n  const intDesignatorLaunchNumber = {\n    start: 11,\n    length: 3,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * International Designator  (COSPAR ID): Piece of the launch.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: A to ZZZ\n   * Example: 'A'\n   */\n\n  const intDesignatorPieceOfLaunch = {\n    start: 14,\n    length: 3,\n    type: _TLE_DATA_TYPES._CHAR\n  };\n  /**\n   * Year when the TLE was generated (TLE epoch), last two digits.\n   *\n   * Range: 00 to 99\n   * Example: 17\n   */\n\n  const epochYear = {\n    start: 18,\n    length: 2,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Fractional day of the year when the TLE was generated (TLE epoch).\n   *\n   * Range: 1 to 365.99999999\n   * Example: 206.18396726\n   */\n\n  const epochDay = {\n    start: 20,\n    length: 12,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * First Time Derivative of the Mean Motion divided by two.  Defines how mean motion changes\n   * from day to day, so TLE propagators can still be used to make reasonable guesses when\n   * times are distant from the original TLE epoch.\n   *\n   * Units: Orbits / day ^ 2\n   * Example: 0.00001961\n   */\n\n  const firstTimeDerivative = {\n    start: 33,\n    length: 11,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Second Time Derivative of Mean Motion divided by six (decimal point assumed). Measures rate\n   * of change in the Mean Motion Dot so software can make reasonable guesses when times are\n   * distant from the original TLE epoch.\n   *\n   * Usually zero, unless the satellite is manuevering or in a decaying orbit.\n   *\n   * Units: Orbits / day ^ 3.\n   * Example: 0 ('00000-0' in the original TLE [= 0.00000 * 10 ^ 0])\n   */\n\n  const secondTimeDerivative = {\n    start: 44,\n    length: 8,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED_E\n  };\n  /**\n   * BSTAR drag term (decimal point assumed).  Estimates the effects of\n   * atmospheric drag on the satellite's motion.\n   *\n   * Units: EarthRadii ^ -1\n   * Example: 0.000036771 ('36771-4' in the original TLE [= 0.36771 * 10 ^ -4])\n   */\n\n  const bstarDrag = {\n    start: 53,\n    length: 8,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED_E\n  };\n  /**\n   * Private value - used by Air Force Space Command to reference the orbit model used to\n   * generate the TLE.  Will always be seen as zero externally (e.g. by \"us\", unless you are\n   * \"them\" - in which case, hello!).\n   *\n   * Example: 0\n   */\n\n  const orbitModel = {\n    start: 62,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * TLE element set number, incremented for each new TLE generated. 999 seems to mean the TLE\n   * has maxed out.\n   *\n   * Range: Technically 1 to 9999, though in practice the maximum number seems to be 999.\n   * Example: 999\n   */\n\n  const tleSetNumber = {\n    start: 64,\n    length: 4,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /*\n   * TLE line 1 checksum (modulo 10), for verifying the integrity of this line of the TLE.\n   *\n   * Range: 0 to 9\n   * Example: 3\n   */\n\n  const checksum1 = {\n    start: 68,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n\n  /**\n   * General helper to get a piece of data from the first line of a TLE.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Object} definition From `line-1-definitions.js`\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFromLine1(tle, definition, isTLEParsed = false) {\n    const parsedTLE = isTLEParsed ? tle : parseTLE(tle);\n    return getFromTLE(parsedTLE, 1, definition);\n  }\n  /**\n   * Returns the line number from line 1.  Should always return \"1\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getLineNumber1(tle, isTLEParsed) {\n    return getFromLine1(tle, lineNumber1, isTLEParsed);\n  }\n  /**\n   * Returns the Space Catalog Number (aka NORAD Catalog Number).\n   * See https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getCatalogNumber1(tle, isTLEParsed) {\n    return getFromLine1(tle, catalogNumber1, isTLEParsed);\n  }\n  /**\n   * Returns the satellite classification.  For example, an unclassified satellite will return `U`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getClassification(tle, isTLEParsed) {\n    return getFromLine1(tle, classification, isTLEParsed);\n  }\n  /**\n   * Returns the launch year (last two digits), which makes up part of the COSPAR id\n   * (international designator).  For example, a satellite launched in 1999 will return \"99\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getIntDesignatorYear(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorYear, isTLEParsed);\n  }\n  /**\n   * Returns the launch number of the year, which makes up part of the COSPAR id\n   * (international designator).  For example, the 50th launch of the year will return \"50\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getIntDesignatorLaunchNumber(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorLaunchNumber, isTLEParsed);\n  }\n  /**\n   * Returns the piece of the launch, which makes up part of the COSPAR id (international designator).\n   * For example, the first piece of the launch will return \"A\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getIntDesignatorPieceOfLaunch(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorPieceOfLaunch, isTLEParsed);\n  }\n  /**\n   * Returns the TLE epoch year (last two digits) when the TLE was generated.  For example, a TLE\n   * generated in 2022 will return `22`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getEpochYear(tle, isTLEParsed) {\n    return getFromLine1(tle, epochYear, isTLEParsed);\n  }\n  /**\n   * Returns the TLE epoch day of the year (day of year with fractional portion of the day) when the\n   * TLE was generated.  For example, a TLE generated on January 1 will return something like\n   * `1.18396726`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getEpochDay(tle, isTLEParsed) {\n    return getFromLine1(tle, epochDay, isTLEParsed);\n  }\n  /**\n   * First Time Derivative of the Mean Motion divided by two, measured in orbits per day per day\n   * (orbits/day2). Defines how mean motion changes from day to day, so TLE propagators can still be\n   * used to make reasonable guesses when distant from the original TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFirstTimeDerivative(tle, isTLEParsed) {\n    return getFromLine1(tle, firstTimeDerivative, isTLEParsed);\n  }\n  /**\n   * Second Time Derivative of Mean Motion divided by six, measured in orbits per day per day per day\n   * (orbits/day3). Similar to the first time derivative, it measures rate of change in the Mean\n   * Motion Dot so software can make reasonable guesses when distant from the original TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Motion and http://castor2.ca/03_Mechanics/03_TLE/Mean_Mot_Dot.html\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getSecondTimeDerivative(tle, isTLEParsed) {\n    return getFromLine1(tle, secondTimeDerivative, isTLEParsed);\n  }\n  /**\n   * BSTAR drag term. This estimates the effects of atmospheric drag on the satellite's motion.\n   * See https://en.wikipedia.org/wiki/BSTAR\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getBstarDrag(tle, isTLEParsed) {\n    return getFromLine1(tle, bstarDrag, isTLEParsed);\n  }\n  /**\n   * Private value - used by Air Force Space Command to reference the orbit model used to generate the\n   * TLE (e.g. SGP, SGP4).  Distributed TLES will always return `0` for this value.  Note that all\n   * distributed TLEs are generated with SGP4/SDP4.\n   * See https://celestrak.com/columns/v04n03/\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getOrbitModel(tle, isTLEParsed) {\n    return getFromLine1(tle, orbitModel, isTLEParsed);\n  }\n  /**\n   * TLE element set number, incremented for each new TLE generated since launch. 999 seems to mean\n   * the TLE has maxed out.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getTleSetNumber(tle, isTLEParsed) {\n    return getFromLine1(tle, tleSetNumber, isTLEParsed);\n  }\n  /**\n   * TLE line 1 checksum (modulo 10), for verifying the integrity of this line of the TLE. Note that\n   * letters, blanks, periods, and plus signs are counted as 0, while minus signs are counted as 1.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getChecksum1(tle, isTLEParsed) {\n    return getFromLine1(tle, checksum1, isTLEParsed);\n  }\n\n  /**\n   * Two-Line Element Set (TLE) format definitions, Line 2\n   * See https://en.wikipedia.org/wiki/Two-line_element_set and https://celestrak.com/columns/v04n03/\n   */\n\n  /* TLE line number. Will always return 2 for valid TLEs. */\n\n  const lineNumber2 = {\n    start: 0,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * NORAD satellite catalog number (Sputnik's rocket was 00001).  Should match the satellite\n   * number on line 1.\n   *\n   * Range: 0 to 99999\n   * Example: 25544\n   */\n\n  const catalogNumber2 = {\n    start: 2,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a\n   * prograde orbit and 90 to 180 degrees is a retrograde orbit.\n   *\n   * Units: degrees\n   * Range: 0 to 180\n   * Example: 51.6400\n   */\n\n  const inclination = {\n    start: 8,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Right ascension of the ascending node in degrees. Essentially, this is the angle of the\n   * satellite as it crosses northward (ascending) across the Earth's equator (equatorial\n   * plane).\n   *\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 208.9163\n   */\n\n  const rightAscension = {\n    start: 17,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Orbital eccentricity, decimal point assumed. All artifical Earth satellites have an\n   * eccentricity between 0 (perfect circle) and 1 (parabolic orbit).\n   *\n   * Range: 0 to 1\n   * Example: 0.0006317 (`0006317` in the original TLE)\n   */\n\n  const eccentricity = {\n    start: 26,\n    length: 7,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED\n  };\n  /**\n   * Argument of perigee. See https://en.wikipedia.org/wiki/Argument_of_perigee\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 69.9862\n   */\n\n  const perigee = {\n    start: 34,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Mean anomaly. Indicates where the satellite was located within its orbit at the time of the\n   * TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Anomaly\n   *\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 25.2906\n   */\n\n  const meanAnomaly = {\n    start: 43,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Revolutions around the Earth per day (mean motion).\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * Range: 0 to 17 (theoretically)\n   * Example: 15.54225995\n   */\n\n  const meanMotion = {\n    start: 52,\n    length: 11,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Total satellite revolutions when this TLE was generated. This number seems to roll over\n   * (e.g. 99999 -> 0).\n   *\n   * Range: 0 to 99999\n   * Example: 6766\n   */\n\n  const revNumberAtEpoch = {\n    start: 63,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /*\n   * TLE line 2 checksum (modulo 10), for verifying the integrity of this line of the TLE.\n   *\n   * Range: 0 to 9\n   * Example: 0\n   */\n\n  const checksum2 = {\n    start: 68,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n\n  /**\n   * General helper to get a piece of data from the second line of a TLE.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Object} definition From `line-1-definitions.js`\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFromLine2(tle, definition, isTLEParsed = false) {\n    const parsedTLE = isTLEParsed ? tle : parseTLE(tle);\n    return getFromTLE(parsedTLE, 2, definition);\n  }\n  /**\n   * Returns the line number from line 2.  Should always return \"2\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getLineNumber2(tle, isTLEParsed) {\n    return getFromLine2(tle, lineNumber2, isTLEParsed);\n  }\n  /**\n   * Returns the line number from line 1.  Should always return \"1\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getCatalogNumber2(tle, isTLEParsed) {\n    return getFromLine2(tle, catalogNumber2, isTLEParsed);\n  }\n  /**\n   * Returns the inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a\n   * prograde orbit and 90 to 180 degrees is a retrograde orbit.\n   * See https://en.wikipedia.org/wiki/Orbital_inclination\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getInclination(tle, isTLEParsed) {\n    return getFromLine2(tle, inclination, isTLEParsed);\n  }\n  /**\n   * Returns the right ascension of the ascending node in degrees. Essentially, this is the angle of\n   * the satellite as it crosses northward (ascending) across the Earth's equator (equatorial plane).\n   * See https://en.wikipedia.org/wiki/Right_ascension_of_the_ascending_node\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getRightAscension(tle, isTLEParsed) {\n    return getFromLine2(tle, rightAscension, isTLEParsed);\n  }\n  /**\n   * Returns the orbital eccentricity. All artificial Earth satellites have an eccentricity between 0\n   * (perfect circle) and 1 (parabolic orbit).\n   * See https://en.wikipedia.org/wiki/Orbital_eccentricity\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getEccentricity(tle, isTLEParsed) {\n    return getFromLine2(tle, eccentricity, isTLEParsed);\n  }\n  /**\n   * Returns the argument of perigee.\n   * See https://en.wikipedia.org/wiki/Argument_of_perigee\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getPerigee(tle, isTLEParsed) {\n    return getFromLine2(tle, perigee, isTLEParsed);\n  }\n  /**\n   * Returns the Mean Anomaly. Indicates where the satellite was located within its orbit at the time\n   * of the TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Anomaly\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getMeanAnomaly(tle, isTLEParsed) {\n    return getFromLine2(tle, meanAnomaly, isTLEParsed);\n  }\n  /**\n   * Returns the revolutions around the Earth per day (mean motion).\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getMeanMotion(tle, isTLEParsed) {\n    return getFromLine2(tle, meanMotion, isTLEParsed);\n  }\n  /**\n   * Returns the total satellite revolutions when this TLE was generated. This number seems to roll\n   * over (e.g. 99999 -> 0).\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getRevNumberAtEpoch(tle, isTLEParsed) {\n    return getFromLine2(tle, revNumberAtEpoch, isTLEParsed);\n  }\n  /**\n   * TLE line 2 checksum (modulo 10), for verifying the integrity of this line of the TLE. Note that\n   * letters, blanks, periods, and plus signs are counted as 0, while minus signs are counted as 1.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getChecksum2(tle, isTLEParsed) {\n    return getFromLine2(tle, checksum2, isTLEParsed);\n  }\n\n  /**\n   * Determines COSPAR ID.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   */\n\n  function getCOSPAR(tle, tleIsParsed) {\n    const partialYear = getIntDesignatorYear(tle, tleIsParsed);\n\n    const fullYear = _getFullYear(partialYear);\n\n    const launchNum = getIntDesignatorLaunchNumber(tle, tleIsParsed);\n    const launchNumWithPadding = launchNum.toString().padStart(3, 0);\n    const launchPiece = getIntDesignatorPieceOfLaunch(tle, tleIsParsed);\n    return `${fullYear}-${launchNumWithPadding}${launchPiece}`;\n  }\n  /**\n   * Determines the name of a satellite, if present in the first line of a 3-line TLE.  If not found,\n   * returns \"Unknown\" by default, or the COSPAR id when fallbackToCOSPAR is true.\n   *\n   * Example:\n   * getSatelliteName(tleStr);\n   * -> 'ISS (ZARYA)'\n   *\n   * @param {String|Array} rawTLE Input TLE.\n   * @param {Boolean} fallbackToCOSPAR Returns COSPAR id when satellite name isn't found.\n   */\n\n  function getSatelliteName(rawTLE, fallbackToCOSPAR = false) {\n    const parsedTLE = parseTLE(rawTLE);\n    const {\n      name\n    } = parsedTLE;\n\n    if (fallbackToCOSPAR) {\n      return name || getCOSPAR(parsedTLE, true);\n    } else {\n      return name || \"Unknown\";\n    }\n  }\n  /**\n   * Determines the Unix timestamp (in ms) of a TLE epoch (the time a TLE was generated).\n   *\n   * Example:\n   * getEpochTimestamp(tleStr);\n   * -> 1500956694771\n   */\n\n  function getEpochTimestamp(rawTLE) {\n    const epochDay = getEpochDay(rawTLE);\n    const epochYear = getEpochYear(rawTLE);\n    return _dayOfYearToTimeStamp(epochDay, epochYear);\n  }\n  /**\n   * Determines the average amount of milliseconds in one orbit.\n   */\n\n  function getAverageOrbitTimeMS(tle) {\n    return parseInt(_MS_IN_A_DAY / getMeanMotion(tle), 10);\n  }\n  /**\n   * Determines the average amount of minutes in one orbit.\n   */\n\n  function getAverageOrbitTimeMins(tle) {\n    return getAverageOrbitTimeMS(tle) / _MS_IN_A_MINUTE;\n  }\n  /**\n   * Determines the average amount of seconds in one orbit.\n   */\n\n  function getAverageOrbitTimeS(tle) {\n    return getAverageOrbitTimeMS(tle) / _MS_IN_A_SECOND;\n  }\n\n  const _SAT_REC_ERRORS = {\n    _DEFAULT: \"Problematic TLE with unknown error.\",\n    1: \"Mean elements, ecc >= 1.0 or ecc < -0.001 or a < 0.95 er\",\n    2: \"Mean motion less than 0.0\",\n    3: \"Pert elements, ecc < 0.0  or  ecc > 1.0\",\n    4: \"Semi-latus rectum < 0.0\",\n    5: \"Epoch elements are sub-orbital\",\n    6: \"Satellite has decayed\"\n  };\n  let cachedSatelliteInfo = {};\n  let cachedAntemeridianCrossings = {};\n  let cachedOrbitTracks = {};\n  let cachedVisibleSatellites = {\n    slowMoving: {}\n  };\n  let cachedGroundTrack = {};\n  const caches = [cachedSatelliteInfo, cachedAntemeridianCrossings, cachedOrbitTracks, cachedVisibleSatellites, cachedGroundTrack];\n  function getCacheSizes() {\n    return caches.map(cache => getObjLength);\n  }\n  /**\n   * Provides a way to clear up memory for long-running apps.\n   */\n\n  function clearCache() {\n    cachedVisibleSatellites.slowMoving = [];\n  }\n  /**\n  \t * Determines satellite position and look angles from an earth observer.\n  \t *\n  \t * Example:\n  \t * const satInfo = getSatelliteInfo(\n  \t *   tleStr,          // Satellite TLE string or array (2 or 3 line variants).\n  \t *   1501039265000,   // Unix timestamp (ms)\n  \t *   34.243889,       // Observer latitude (degrees)\n  \t *   -116.911389,     // Observer longitude (degrees)\n  \t *   0                // Observer elevation (km)\n  \t * );\n  \t *\n  \t * ->\n  \t * {\n  \t *   // satellite compass heading from observer in degrees (0 = north, 180 = south)\n  \t *   azimuth: 294.5780478624994,\n  \t *\n  \t *   // satellite elevation from observer in degrees (90 is directly overhead)\n  \t *   elevation: 81.63903620330046,\n  \t *\n  \t *   // km distance from observer to spacecraft\n  \t *   range: 406.60211015810074,\n  \t *\n  \t *   // spacecraft altitude in km\n  \t *   height: 402.9082788620108,\n\n  \t *   // spacecraft latitude in degrees\n  \t *   lat: 34.45112876592785,\n\n  \t *   // spacecraft longitude in degrees\n  \t *   lng: -117.46176597710809,\n  \t *\n  \t *   // spacecraft velocity in km/s\n  \t *   velocity: 7.675627442183371\n  \t * }\n  \t */\n\n  function getSatelliteInfo(rawTLE, rawTimestamp, observerLat, observerLng, observerHeight) {\n    const timestamp = rawTimestamp || Date.now();\n    const {\n      tle\n    } = parseTLE(rawTLE);\n    const defaultObserverPosition = {\n      lat: 36.9613422,\n      lng: -122.0308,\n      height: 0.37\n    };\n    const obsLat = observerLat || defaultObserverPosition.lat;\n    const obsLng = observerLng || defaultObserverPosition.lng;\n    const obsHeight = observerHeight || defaultObserverPosition.height; // Memoization\n\n    const cacheKey = `${tle[0]}-${timestamp}-${observerLat}-${observerLng}\n-${observerHeight}`;\n\n    if (cachedSatelliteInfo[cacheKey]) {\n      return cachedSatelliteInfo[cacheKey];\n    } // Initialize a satellite record\n\n\n    const satrec = satellite_js.twoline2satrec(tle[0], tle[1]);\n\n    if (satrec.error) {\n      throw new Error(_SAT_REC_ERRORS[satrec.error] || _SAT_REC_ERRORS._DEFAULT);\n    }\n\n    const dateObj = new Date(timestamp); // Propagate SGP4.\n\n    const positionAndVelocity = satellite_js.propagate(satrec, dateObj); // The position_velocity result is a key-value pair of ECI coordinates.\n    // These are the base results from which all other coordinates are derived.\n\n    const positionEci = positionAndVelocity.position;\n    const velocityEci = positionAndVelocity.velocity; // Set the observer position (in radians).\n\n    const observerGd = {\n      latitude: _degreesToRadians(obsLat),\n      longitude: _degreesToRadians(obsLng),\n      height: obsHeight\n    }; // Get GMST for some coordinate transforms.\n    // http://en.wikipedia.org/wiki/Sidereal_time#Definition\n\n    const gmst = satellite_js.gstime(dateObj); // Get ECF, Geodetic, Look Angles, and Doppler Factor.\n\n    const positionEcf = satellite_js.eciToEcf(positionEci, gmst);\n    const positionGd = satellite_js.eciToGeodetic(positionEci, gmst);\n    const lookAngles = satellite_js.ecfToLookAngles(observerGd, positionEcf);\n    const velocityKmS = Math.sqrt(Math.pow(velocityEci.x, 2) + Math.pow(velocityEci.y, 2) + Math.pow(velocityEci.z, 2)); // Azimuth: is simply the compass heading from the observer's position.\n\n    const {\n      azimuth,\n      elevation,\n      rangeSat\n    } = lookAngles; // Geodetic coords are accessed via `longitude`, `latitude`, `height`.\n\n    const {\n      longitude,\n      latitude,\n      height\n    } = positionGd;\n    const output = {\n      lng: satellite_js.degreesLong(longitude),\n      lat: satellite_js.degreesLat(latitude),\n      elevation: _radiansToDegrees(elevation),\n      azimuth: _radiansToDegrees(azimuth),\n      range: rangeSat,\n      height,\n      velocity: velocityKmS\n    }; // Memoization\n\n    cachedSatelliteInfo[cacheKey] = output;\n    return output;\n  }\n  /**\n   * Determines if the last antemeridian crossing has been cached.  If it has, the time (in ms)\n   * is returned, otherwise it returns false.\n   */\n\n  function getCachedLastAntemeridianCrossingTimeMS(tleObj, timeMS) {\n    const {\n      tle\n    } = tleObj;\n    const orbitLengthMS = getAverageOrbitTimeMins(tle) * 60 * 1000;\n    const tleStr = tle[0].substr(0, 30);\n    const cachedCrossingTimes = cachedAntemeridianCrossings[tleStr];\n    if (!cachedCrossingTimes) return false;\n    if (cachedCrossingTimes === -1) return cachedCrossingTimes;\n    const cachedTime = cachedCrossingTimes.filter(val => {\n      if (typeof val === \"object\" && val.tle === tle) return -1;\n      const diff = timeMS - val;\n      const isDiffPositive = diff > 0;\n      const isWithinOrbit = isDiffPositive && diff < orbitLengthMS;\n      return isWithinOrbit;\n    });\n    return cachedTime[0] || false;\n  }\n  /**\n   * Determines the last time the satellite crossed the antemeridian.  For mapping convenience\n   * and to avoid headaches, we want to avoid plotting ground tracks that cross the antemeridian.\n   */\n\n  function getLastAntemeridianCrossingTimeMS(tle, timeMS) {\n    const parsedTLE = parseTLE(tle);\n    const {\n      tle: tleArr\n    } = parsedTLE;\n    const cachedVal = getCachedLastAntemeridianCrossingTimeMS(parsedTLE, timeMS);\n\n    if (cachedVal) {\n      return cachedVal;\n    }\n\n    const time = timeMS || Date.now();\n    let step = 1000 * 60 * 10;\n    let curLngLat = [];\n    let lastLngLat = [];\n    let curTimeMS = time;\n    let didCrossAntemeridian = false;\n    let tries = 0;\n    let isDone = false;\n    const maxTries = 1000;\n\n    while (!isDone) {\n      curLngLat = getLngLat(tleArr, curTimeMS);\n      const [curLng, curLat] = curLngLat;\n      didCrossAntemeridian = _crossesAntemeridian(lastLngLat[0], curLng);\n\n      if (didCrossAntemeridian) {\n        // Back up a bit, then keep halving the step increment till we get close enough.\n        curTimeMS += step;\n        step = step > 20000 ? 20000 : step / 2;\n      } else {\n        curTimeMS -= step;\n        lastLngLat = curLngLat;\n      }\n\n      isDone = step < 500 || tries >= maxTries;\n      tries++;\n    }\n\n    const couldNotFindCrossing = tries - 1 === maxTries;\n    const crossingTime = couldNotFindCrossing ? -1 : parseInt(curTimeMS, 10);\n    const tleStr = tleArr[0];\n\n    if (!cachedAntemeridianCrossings[tleStr]) {\n      cachedAntemeridianCrossings[tleStr] = [];\n    }\n\n    if (couldNotFindCrossing) {\n      cachedAntemeridianCrossings[tleStr] = -1;\n    } else {\n      cachedAntemeridianCrossings[tleStr].push(crossingTime);\n    }\n\n    return crossingTime;\n  }\n  /**\n   * Determines current satellite position, or position at time of timestamp (optional).\n   *\n   * @param {Array|String} tle\n   * @param {Number} optionalTimestamp Unix timestamp in milliseconds.\n   */\n\n  function getLatLngObj(tle, optionalTimestamp = Date.now()) {\n    const {\n      lat,\n      lng\n    } = getSatelliteInfo(tle, optionalTimestamp);\n    return {\n      lat,\n      lng\n    };\n  }\n  /**\n   * Determines current satellite position, or position at time of timestamp (optional).\n   *\n   * @param {Array|String} tle\n   * @param {Number} optionalTimestamp Unix timestamp in milliseconds.\n   */\n\n  function getLngLat(tle, optionalTimestamp = Date.now()) {\n    const {\n      lat,\n      lng\n    } = getSatelliteInfo(tle, optionalTimestamp);\n    return [lng, lat];\n  }\n  /**\n   * Determines the position of the satellite at the time the TLE was generated.\n   *\n   * @param {Array|String} tle\n   */\n\n  function getLngLatAtEpoch(tle) {\n    return getLngLat(tle, getEpochTimestamp(tle));\n  } // TODO: cache geosync and erroring satellites and don't recompute on next pass.\n\n  function getVisibleSatellites({\n    observerLat,\n    observerLng,\n    observerHeight = 0,\n    tles = [],\n    elevationThreshold = 0,\n    timestampMS = Date.now()\n  }) {\n    return tles.reduce((visibleSats, tleArr, index) => {\n      // Don't waste time reprocessing geosync.\n      const cacheKey = tleArr[1];\n      const cachedVal = cachedVisibleSatellites.slowMoving[cacheKey];\n\n      if (cachedVal) {\n        const {\n          info\n        } = cachedVal;\n        const {\n          elevation: cachedElevation\n        } = info;\n        return cachedElevation >= elevationThreshold ? visibleSats.concat(cachedVal) : visibleSats;\n      }\n\n      let info;\n\n      try {\n        info = getSatelliteInfo(tleArr, timestampMS, observerLat, observerLng, observerHeight);\n      } catch (e) {\n        // Don't worry about decayed sats, just move on.\n        // TODO cache error\n        return visibleSats;\n      }\n\n      const {\n        elevation,\n        velocity,\n        range\n      } = info;\n      const isSlowMoving = velocity / range < 0.001;\n\n      if (isSlowMoving) {\n        cachedVisibleSatellites.slowMoving[cacheKey] = {\n          tleArr,\n          info\n        };\n      }\n\n      return elevation >= elevationThreshold ? visibleSats.concat({\n        tleArr,\n        info\n      }) : visibleSats;\n    }, []);\n  }\n  function* getNextPosition(tleArr, startTimeMS, stepMS) {\n    let curTimeMS = startTimeMS - stepMS;\n\n    while (true) {\n      curTimeMS += stepMS;\n      yield {\n        curTimeMS,\n        lngLat: getLngLat(tleArr, curTimeMS)\n      };\n    }\n  }\n  function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  /**\n   * Generates an array of lng/lat pairs representing a ground track (orbit track), starting\n   * from startTimeMS and continuing until just before crossing the antemeridian, which is considered the end\n   * of the orbit for convenience.\n   *\n   * Consider pairing this with getLastAntemeridianCrossingTimeMS() to create a full orbit path (see usage\n   * in getGroundTracks()).\n   */\n\n  function getOrbitTrack({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    sleepMS = 0,\n    jobChunkSize = 1000,\n    maxTimeMS = 6000000,\n    isLngLatFormat = true\n  }) {\n    return new Promise(async (resolve, reject) => {\n      const {\n        tle: tleArr\n      } = parseTLE(tle);\n      const startS = (startTimeMS / 1000).toFixed();\n      const cacheKey = `${tleArr[0]}-${startS}-${stepMS}-${isLngLatFormat}`;\n\n      if (cachedOrbitTracks[cacheKey]) {\n        resolve(cachedOrbitTracks[cacheKey]);\n        return;\n      }\n\n      const generator = getNextPosition(tleArr, startTimeMS, stepMS);\n      let step = 0;\n      let isDone = false;\n      let coords = [];\n      let lastLng;\n\n      while (!isDone) {\n        const {\n          curTimeMS,\n          lngLat\n        } = generator.next().value;\n        const [curLng, curLat] = lngLat;\n\n        const doesCrossAntemeridian = _crossesAntemeridian(lastLng, curLng);\n\n        const doesExceedTime = maxTimeMS && curTimeMS - startTimeMS > maxTimeMS;\n        isDone = doesCrossAntemeridian || doesExceedTime;\n\n        if (isLngLatFormat) {\n          coords.push(lngLat);\n        } else {\n          coords.push([curLat, curLng]);\n        }\n\n        if (sleepMS && step % jobChunkSize === 0) {\n          // Chunk is processed, so cool off a bit.\n          await sleep(sleepMS);\n        }\n\n        lastLng = curLng;\n        step++;\n      }\n\n      cachedOrbitTracks[cacheKey] = coords;\n      resolve(coords);\n    });\n  }\n  /**\n   *\n   */\n\n  function getOrbitTrackSync({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    maxTimeMS = 6000000,\n    isLngLatFormat = true\n  }) {\n    const {\n      tle: tleArr\n    } = parseTLE(tle);\n    const startS = (startTimeMS / 1000).toFixed();\n    const cacheKey = `${tleArr[0]}-${startS}-${stepMS}-${isLngLatFormat}`;\n\n    if (cachedOrbitTracks[cacheKey]) {\n      return cachedOrbitTracks[cacheKey];\n    }\n\n    let isDone = false;\n    let coords = [];\n    let lastLng;\n    let curTimeMS = startTimeMS;\n\n    while (!isDone) {\n      const curLngLat = getLngLat(tleArr, curTimeMS);\n      const [curLng, curLat] = curLngLat;\n\n      const doesCrossAntemeridian = _crossesAntemeridian(lastLng, curLng);\n\n      const doesExceedTime = maxTimeMS && curTimeMS - startTimeMS > maxTimeMS;\n      isDone = doesCrossAntemeridian || doesExceedTime;\n\n      if (isLngLatFormat) {\n        coords.push(curLngLat);\n      } else {\n        coords.push([curLat, curLng]);\n      }\n\n      lastLng = curLng;\n      curTimeMS += stepMS;\n    }\n\n    cachedOrbitTracks[cacheKey] = coords;\n    return coords;\n  }\n  /**\n   * Calculates three orbit arrays of latitude/longitude pairs.\n   * TODO: just calculate future orbits\n   *\n   * @param {Array|String} options.tle\n   * @param {Number} startTimeMS Unix timestamp in milliseconds.\n   * @param {Number} stepMS Time in milliseconds between points on the ground track.\n   * @param {Boolean} isLngLatFormat Formats coords in [lng, lat] order when true, [lat, lng] when false.\n   * \n   *\n   * Example:\n   * const threeOrbitsArr = await getGroundTracks({ tle: tleStr });\n   * ->\n   * [\n   *   // previous orbit\n   *   [\n   *     [ 45.85524291891481, -179.93297540317567 ],\n   *     ...\n   *   ],\n   *\n   *   // current orbit\n   *   [\n   *     [ 51.26165992503701, -179.9398612198045 ],\n   *     ...\n   *   ],\n   *\n   *   // next orbit\n   *   [\n   *     [ 51.0273714070371, -179.9190165549038 ],\n   *     ...\n   *   ]\n   * ]\n   */\n\n  function getGroundTracks({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    isLngLatFormat = true\n  }) {\n    return new Promise(async (resolve, reject) => {\n      const parsedTLE = parseTLE(tle);\n      const orbitTimeMS = getAverageOrbitTimeMS(parsedTLE);\n      const curOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, startTimeMS);\n      const foundCrossing = curOrbitStartMS !== -1;\n\n      if (!foundCrossing) {\n        // Geosync or unusual orbit, so just return a partial orbit track.\n        const partialGroundTrack = await getOrbitTrack({\n          tle: parsedTLE,\n          startTimeMS,\n          stepMS: _MS_IN_A_MINUTE,\n          maxTimeMS: _MS_IN_A_DAY / 4,\n          isLngLatFormat\n        });\n        resolve([partialGroundTrack]);\n        return;\n      }\n\n      const lastOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, // TODO: fix this magic math\n      curOrbitStartMS - 10000);\n      const nextOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, // TODO: fix this magic math\n      curOrbitStartMS + orbitTimeMS + 1000 * 60 * 30);\n      const groundTrackPromises = [getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: lastOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      }), getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: curOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      }), getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: nextOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      })];\n      const threeOrbitTracks = await Promise.all(groundTrackPromises);\n      resolve(threeOrbitTracks);\n    });\n  }\n  /**\n   * Calculates three orbit arrays of latitude/longitude pairs.\n   *\n   * Example:\n   * const threeOrbitsArr = getGroundTrackSync({ tle: tleStr });\n   * ->\n   * [\n   *   // previous orbit\n   *   [\n   *     [ 45.85524291891481, -179.93297540317567 ],\n   *     ...\n   *   ],\n   *\n   *   // current orbit\n   *   [\n   *     [ 51.26165992503701, -179.9398612198045 ],\n   *     ...\n   *   ],\n   *\n   *   // next orbit\n   *   [\n   *     [ 51.0273714070371, -179.9190165549038 ],\n   *     ...\n   *   ]\n   * ]\n   */\n\n  function getGroundTracksSync({\n    tle,\n    stepMS = 1000,\n    optionalTimeMS = Date.now(),\n    isLngLatFormat = true\n  }) {\n    const parsedTLE = parseTLE(tle);\n    const {\n      tle: tleArr\n    } = parsedTLE;\n    const orbitTimeMS = getAverageOrbitTimeMS(tleArr);\n    const curOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, optionalTimeMS);\n    const foundCrossing = curOrbitStartMS !== -1;\n\n    if (!foundCrossing) {\n      // Geosync or unusual orbit, so just return a partial orbit track.\n      const partialGroundTrack = getOrbitTrackSync({\n        tle: parsedTLE,\n        startTimeMS: timeMS,\n        stepMS: _MS_IN_A_MINUTE,\n        maxTimeMS: _MS_IN_A_DAY / 4\n      });\n      return partialGroundTrack;\n    }\n\n    const lastOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, curOrbitStartMS - 10000);\n    const nextOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, curOrbitStartMS + orbitTimeMS + 1000 * 60 * 30);\n    const orbitStartTimes = [lastOrbitStartMS, curOrbitStartMS, nextOrbitStartMS];\n    const orbitLatLons = orbitStartTimes.map(orbitStartMS => {\n      return getOrbitTrackSync({\n        tle: parsedTLE,\n        startTimeMS: orbitStartMS,\n        stepMS,\n        isLngLatFormat\n      });\n    });\n    return orbitLatLons;\n  }\n  /**\n   * Determes the compass bearing from the perspective of the satellite.  Useful for 3D / pitched\n   * map perspectives.\n   *\n   * TODO: a bit buggy at extreme parts of orbits, where latitude hardly changes.\n   */\n\n  function getSatBearing(tle, customTimeMS) {\n    const parsedTLE = this.parseTLE(tle);\n    const timeMS = customTimeMS || Date.now();\n    const latLon1 = this.getLatLonArr(parsedTLE.arr, timeMS);\n    const latLon2 = this.getLatLonArr(parsedTLE.arr, timeMS + 10000);\n\n    const doesCrossAntemeridian = _crossesAntemeridian(latLon1[1], latLon2[1]);\n\n    if (doesCrossAntemeridian) {\n      // TODO: fix\n      return {}; // return this.getSatBearing(tle, customTimeMS + 10000);\n    }\n\n    const lat1 = _degreesToRadians(latLon1[0]);\n\n    const lat2 = _degreesToRadians(latLon2[0]);\n\n    const lon1 = _degreesToRadians(latLon1[1]);\n\n    const lon2 = _degreesToRadians(latLon2[1]);\n\n    const NS = lat1 >= lat2 ? \"S\" : \"N\";\n    const EW = lon1 >= lon2 ? \"W\" : \"E\";\n    const y = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    const degrees = _radiansToDegrees(Math.atan2(y, x));\n\n    return {\n      degrees,\n      compass: `${NS}${EW}`\n    };\n  }\n\n  exports.clearCache = clearCache;\n  exports.computeChecksum = computeChecksum;\n  exports.getAverageOrbitTimeMS = getAverageOrbitTimeMS;\n  exports.getAverageOrbitTimeMins = getAverageOrbitTimeMins;\n  exports.getAverageOrbitTimeS = getAverageOrbitTimeS;\n  exports.getBstarDrag = getBstarDrag;\n  exports.getCOSPAR = getCOSPAR;\n  exports.getCacheSizes = getCacheSizes;\n  exports.getCatalogNumber = getCatalogNumber1;\n  exports.getCatalogNumber1 = getCatalogNumber1;\n  exports.getCatalogNumber2 = getCatalogNumber2;\n  exports.getChecksum1 = getChecksum1;\n  exports.getChecksum2 = getChecksum2;\n  exports.getClassification = getClassification;\n  exports.getEccentricity = getEccentricity;\n  exports.getEpochDay = getEpochDay;\n  exports.getEpochTimestamp = getEpochTimestamp;\n  exports.getEpochYear = getEpochYear;\n  exports.getFirstTimeDerivative = getFirstTimeDerivative;\n  exports.getGroundTracks = getGroundTracks;\n  exports.getGroundTracksSync = getGroundTracksSync;\n  exports.getInclination = getInclination;\n  exports.getIntDesignatorLaunchNumber = getIntDesignatorLaunchNumber;\n  exports.getIntDesignatorPieceOfLaunch = getIntDesignatorPieceOfLaunch;\n  exports.getIntDesignatorYear = getIntDesignatorYear;\n  exports.getLastAntemeridianCrossingTimeMS = getLastAntemeridianCrossingTimeMS;\n  exports.getLatLngObj = getLatLngObj;\n  exports.getLineNumber1 = getLineNumber1;\n  exports.getLineNumber2 = getLineNumber2;\n  exports.getLngLatAtEpoch = getLngLatAtEpoch;\n  exports.getMeanAnomaly = getMeanAnomaly;\n  exports.getMeanMotion = getMeanMotion;\n  exports.getOrbitModel = getOrbitModel;\n  exports.getOrbitTrack = getOrbitTrack;\n  exports.getOrbitTrackSync = getOrbitTrackSync;\n  exports.getPerigee = getPerigee;\n  exports.getRevNumberAtEpoch = getRevNumberAtEpoch;\n  exports.getRightAscension = getRightAscension;\n  exports.getSatBearing = getSatBearing;\n  exports.getSatelliteInfo = getSatelliteInfo;\n  exports.getSatelliteName = getSatelliteName;\n  exports.getSecondTimeDerivative = getSecondTimeDerivative;\n  exports.getTleSetNumber = getTleSetNumber;\n  exports.getVisibleSatellites = getVisibleSatellites;\n  exports.isValidTLE = isValidTLE;\n  exports.parseTLE = parseTLE;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}