{"ast":null,"code":"import withAccessors from '../mixins/with-accessors';\nimport HasObservers from '../core/has-observers';\nimport { defined, MIN_NUM, MAX_NUM, round } from '../util';\nimport Matrix from './matrix';\nimport toMatrix from './to-matrix';\n\nvar Point = function (superclass) {\n  function Point(x, y) {\n    superclass.call(this);\n    this.x = x || 0;\n    this.y = y || 0;\n  }\n\n  if (superclass) Point.__proto__ = superclass;\n  Point.prototype = Object.create(superclass && superclass.prototype);\n  Point.prototype.constructor = Point;\n  var staticAccessors = {\n    ZERO: {\n      configurable: true\n    }\n  };\n\n  Point.prototype.equals = function equals(other) {\n    return other && other.x === this.x && other.y === this.y;\n  };\n\n  Point.prototype.clone = function clone() {\n    return new Point(this.x, this.y);\n  };\n\n  Point.prototype.rotate = function rotate(angle, origin) {\n    var originPoint = Point.create(origin) || Point.ZERO;\n    return this.transform(Matrix.rotate(angle, originPoint.x, originPoint.y));\n  };\n\n  Point.prototype.translate = function translate(x, y) {\n    this.x += x;\n    this.y += y;\n    this.geometryChange();\n    return this;\n  };\n\n  Point.prototype.translateWith = function translateWith(point) {\n    return this.translate(point.x, point.y);\n  };\n\n  Point.prototype.move = function move(x, y) {\n    this.x = this.y = 0;\n    return this.translate(x, y);\n  };\n\n  Point.prototype.scale = function scale(scaleX, scaleY) {\n    if (scaleY === void 0) scaleY = scaleX;\n    this.x *= scaleX;\n    this.y *= scaleY;\n    this.geometryChange();\n    return this;\n  };\n\n  Point.prototype.scaleCopy = function scaleCopy(scaleX, scaleY) {\n    return this.clone().scale(scaleX, scaleY);\n  };\n\n  Point.prototype.transform = function transform(transformation) {\n    var matrix = toMatrix(transformation);\n    var ref = this;\n    var x = ref.x;\n    var y = ref.y;\n    this.x = matrix.a * x + matrix.c * y + matrix.e;\n    this.y = matrix.b * x + matrix.d * y + matrix.f;\n    this.geometryChange();\n    return this;\n  };\n\n  Point.prototype.transformCopy = function transformCopy(transformation) {\n    var point = this.clone();\n\n    if (transformation) {\n      point.transform(transformation);\n    }\n\n    return point;\n  };\n\n  Point.prototype.distanceTo = function distanceTo(point) {\n    var dx = this.x - point.x;\n    var dy = this.y - point.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  Point.prototype.round = function round$1(digits) {\n    this.x = round(this.x, digits);\n    this.y = round(this.y, digits);\n    this.geometryChange();\n    return this;\n  };\n\n  Point.prototype.toArray = function toArray(digits) {\n    var doRound = defined(digits);\n    var x = doRound ? round(this.x, digits) : this.x;\n    var y = doRound ? round(this.y, digits) : this.y;\n    return [x, y];\n  };\n\n  Point.prototype.toString = function toString(digits, separator) {\n    if (separator === void 0) separator = \" \";\n    var ref = this;\n    var x = ref.x;\n    var y = ref.y;\n\n    if (defined(digits)) {\n      x = round(x, digits);\n      y = round(y, digits);\n    }\n\n    return x + separator + y;\n  };\n\n  Point.create = function create(arg0, arg1) {\n    if (defined(arg0)) {\n      if (arg0 instanceof Point) {\n        return arg0;\n      } else if (arguments.length === 1 && arg0.length === 2) {\n        return new Point(arg0[0], arg0[1]);\n      }\n\n      return new Point(arg0, arg1);\n    }\n  };\n\n  Point.min = function min() {\n    var arguments$1 = arguments;\n    var minX = MAX_NUM;\n    var minY = MAX_NUM;\n\n    for (var i = 0; i < arguments.length; i++) {\n      var point = arguments$1[i];\n      minX = Math.min(point.x, minX);\n      minY = Math.min(point.y, minY);\n    }\n\n    return new Point(minX, minY);\n  };\n\n  Point.max = function max() {\n    var arguments$1 = arguments;\n    var maxX = MIN_NUM;\n    var maxY = MIN_NUM;\n\n    for (var i = 0; i < arguments.length; i++) {\n      var point = arguments$1[i];\n      maxX = Math.max(point.x, maxX);\n      maxY = Math.max(point.y, maxY);\n    }\n\n    return new Point(maxX, maxY);\n  };\n\n  Point.minPoint = function minPoint() {\n    return new Point(MIN_NUM, MIN_NUM);\n  };\n\n  Point.maxPoint = function maxPoint() {\n    return new Point(MAX_NUM, MAX_NUM);\n  };\n\n  staticAccessors.ZERO.get = function () {\n    return new Point(0, 0);\n  };\n\n  Object.defineProperties(Point, staticAccessors);\n  return Point;\n}(withAccessors(HasObservers, [\"x\", \"y\"]));\n\nexport default Point;","map":{"version":3,"sources":["C:/Users/Md. Mehrab Haque/Desktop/satellight/node_modules/@progress/kendo-drawing/dist/es/geometry/point.js"],"names":["withAccessors","HasObservers","defined","MIN_NUM","MAX_NUM","round","Matrix","toMatrix","Point","superclass","x","y","call","__proto__","prototype","Object","create","constructor","staticAccessors","ZERO","configurable","equals","other","clone","rotate","angle","origin","originPoint","transform","translate","geometryChange","translateWith","point","move","scale","scaleX","scaleY","scaleCopy","transformation","matrix","ref","a","c","e","b","d","f","transformCopy","distanceTo","dx","dy","Math","sqrt","round$1","digits","toArray","doRound","toString","separator","arg0","arg1","arguments","length","min","arguments$1","minX","minY","i","max","maxX","maxY","minPoint","maxPoint","get","defineProperties"],"mappings":"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","sourcesContent":["import withAccessors from '../mixins/with-accessors';\nimport HasObservers from '../core/has-observers';\nimport { defined, MIN_NUM, MAX_NUM, round } from '../util';\nimport Matrix from './matrix';\nimport toMatrix from './to-matrix';\n\n\nvar Point = (function (superclass) {\n    function Point(x, y) {\n        superclass.call(this);\n\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n\n    if ( superclass ) Point.__proto__ = superclass;\n    Point.prototype = Object.create( superclass && superclass.prototype );\n    Point.prototype.constructor = Point;\n\n    var staticAccessors = { ZERO: { configurable: true } };\n\n    Point.prototype.equals = function equals (other) {\n        return other && other.x === this.x && other.y === this.y;\n    };\n\n    Point.prototype.clone = function clone () {\n        return new Point(this.x, this.y);\n    };\n\n    Point.prototype.rotate = function rotate (angle, origin) {\n        var originPoint = Point.create(origin) || Point.ZERO;\n\n        return this.transform(Matrix.rotate(angle, originPoint.x, originPoint.y));\n    };\n\n    Point.prototype.translate = function translate (x, y) {\n        this.x += x;\n        this.y += y;\n\n        this.geometryChange();\n\n        return this;\n    };\n\n    Point.prototype.translateWith = function translateWith (point) {\n        return this.translate(point.x, point.y);\n    };\n\n    Point.prototype.move = function move (x, y) {\n        this.x = this.y = 0;\n        return this.translate(x, y);\n    };\n\n    Point.prototype.scale = function scale (scaleX, scaleY) {\n        if ( scaleY === void 0 ) scaleY = scaleX;\n\n        this.x *= scaleX;\n        this.y *= scaleY;\n\n        this.geometryChange();\n\n        return this;\n    };\n\n    Point.prototype.scaleCopy = function scaleCopy (scaleX, scaleY) {\n        return this.clone().scale(scaleX, scaleY);\n    };\n\n    Point.prototype.transform = function transform (transformation) {\n        var matrix = toMatrix(transformation);\n        var ref = this;\n        var x = ref.x;\n        var y = ref.y;\n\n        this.x = matrix.a * x + matrix.c * y + matrix.e;\n        this.y = matrix.b * x + matrix.d * y + matrix.f;\n\n        this.geometryChange();\n\n        return this;\n    };\n\n    Point.prototype.transformCopy = function transformCopy (transformation) {\n        var point = this.clone();\n\n        if (transformation) {\n            point.transform(transformation);\n        }\n\n        return point;\n    };\n\n    Point.prototype.distanceTo = function distanceTo (point) {\n        var dx = this.x - point.x;\n        var dy = this.y - point.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n\n    Point.prototype.round = function round$1 (digits) {\n        this.x = round(this.x, digits);\n        this.y = round(this.y, digits);\n\n        this.geometryChange();\n\n        return this;\n    };\n\n    Point.prototype.toArray = function toArray (digits) {\n        var doRound = defined(digits);\n        var x = doRound ? round(this.x, digits) : this.x;\n        var y = doRound ? round(this.y, digits) : this.y;\n\n        return [ x, y ];\n    };\n\n    Point.prototype.toString = function toString (digits, separator) {\n        if ( separator === void 0 ) separator = \" \";\n\n        var ref = this;\n        var x = ref.x;\n        var y = ref.y;\n\n        if (defined(digits)) {\n            x = round(x, digits);\n            y = round(y, digits);\n        }\n\n        return x + separator + y;\n    };\n\n    Point.create = function create (arg0, arg1) {\n        if (defined(arg0)) {\n            if (arg0 instanceof Point) {\n                return arg0;\n            } else if (arguments.length === 1 && arg0.length === 2) {\n                return new Point(arg0[0], arg0[1]);\n            }\n\n            return new Point(arg0, arg1);\n        }\n    };\n\n    Point.min = function min () {\n        var arguments$1 = arguments;\n\n        var minX = MAX_NUM;\n        var minY = MAX_NUM;\n\n        for (var i = 0; i < arguments.length; i++) {\n            var point = arguments$1[i];\n            minX = Math.min(point.x, minX);\n            minY = Math.min(point.y, minY);\n        }\n\n        return new Point(minX, minY);\n    };\n\n    Point.max = function max () {\n        var arguments$1 = arguments;\n\n        var maxX = MIN_NUM;\n        var maxY = MIN_NUM;\n\n        for (var i = 0; i < arguments.length; i++) {\n            var point = arguments$1[i];\n            maxX = Math.max(point.x, maxX);\n            maxY = Math.max(point.y, maxY);\n        }\n\n        return new Point(maxX, maxY);\n    };\n\n    Point.minPoint = function minPoint () {\n        return new Point(MIN_NUM, MIN_NUM);\n    };\n\n    Point.maxPoint = function maxPoint () {\n        return new Point(MAX_NUM, MAX_NUM);\n    };\n\n    staticAccessors.ZERO.get = function () {\n        return new Point(0, 0);\n    };\n\n    Object.defineProperties( Point, staticAccessors );\n\n    return Point;\n}(withAccessors(HasObservers, [ \"x\", \"y\" ])));\n\nexport default Point;\n"]},"metadata":{},"sourceType":"module"}