{"ast":null,"code":"var _asyncToGenerator = require(\"C:\\\\Users\\\\Md. Mehrab Haque\\\\Desktop\\\\satellight\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Md. Mehrab Haque\\\\Desktop\\\\satellight\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Md. Mehrab Haque\\\\Desktop\\\\satellight\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('satellite.js')) : typeof define === 'function' && define.amd ? define(['exports', 'satellite.js'], factory) : (global = global || self, factory(global.tlejs = {}, global.satellite));\n})(this, function (exports, satellite_js) {\n  'use strict';\n\n  var _marked = /*#__PURE__*/_regeneratorRuntime.mark(getNextPosition);\n\n  var _MS_IN_A_DAY = 86400000;\n  var _MS_IN_A_SECOND = 1000;\n  var _MS_IN_A_MINUTE = 60000; // Data formats for TLE orbital elements.\n\n  var _TLE_DATA_TYPES = {\n    _INT: Symbol(),\n    _FLOAT: Symbol(),\n    _CHAR: Symbol(),\n    _DECIMAL_ASSUMED: Symbol(),\n    // 12345   -> 0.12345\n    _DECIMAL_ASSUMED_E: Symbol() // 12345-2 -> 0.0012345\n\n  };\n  var _DATA_TYPES = {\n    _ARRAY: \"array\",\n    _STRING: \"string\",\n    _OBJECT: \"object\",\n    _DATE: \"date\",\n    _NAN: \"NaN\"\n  };\n  /**\n   * General helper that provides more useful info than JavaScript's built-in \"typeof\" operator.\n   *\n   * Example:\n   * getType([]);\n   * -> 'array'\n   */\n\n  function getType(input) {\n    var type = typeof input;\n\n    if (Array.isArray(input)) {\n      return _DATA_TYPES._ARRAY;\n    }\n\n    if (input instanceof Date) {\n      return _DATA_TYPES._DATE;\n    }\n\n    if (Number.isNaN(input)) {\n      return _DATA_TYPES._NAN;\n    }\n\n    return type;\n  }\n  /**\n   * Determines if a number is positive.\n   */\n\n\n  var _isPositive = function _isPositive(num) {\n    return num >= 0;\n  };\n  /**\n   * Determines the amount of digits in a number.  Used for converting a TLE's \"leading decimal\n   * assumed\" notation.\n   *\n   * Example:\n   * getDigitCount(12345);\n   * -> 5\n   */\n\n\n  var _getDigitCount = function _getDigitCount(num) {\n    var absVal = Math.abs(num);\n    return absVal.toString().length;\n  };\n  /**\n   * Converts a TLE's \"leading decimal assumed\" notation to a float representation.\n   *\n   * Example:\n   * toLeadingDecimal(12345);\n   * -> 0.12345\n   */\n\n\n  var _toLeadingDecimal = function _toLeadingDecimal(num) {\n    var numDigits = _getDigitCount(num);\n\n    var zeroes = \"0\".repeat(numDigits - 1);\n    return parseFloat(num * \"0.\".concat(zeroes, \"1\"));\n  };\n  /**\n   * Converts a TLE's \"leading decimal assumed\" notation with leading zeroes to a float\n   * representation.\n   *\n   * Example:\n   * decimalAssumedEToFloat('12345-4');\n   * -> 0.000012345\n   */\n\n\n  var _decimalAssumedEToFloat = function _decimalAssumedEToFloat(str) {\n    var numWithAssumedLeadingDecimal = str.substr(0, str.length - 2);\n\n    var num = _toLeadingDecimal(numWithAssumedLeadingDecimal);\n\n    var leadingDecimalPoints = parseInt(str.substr(str.length - 2, 2), 10);\n    var float = num * Math.pow(10, leadingDecimalPoints);\n    return parseFloat(float.toPrecision(5));\n  };\n  /**\n   * Converts a fractional day of the year to a timestamp.  Used for parsing the TLE epoch.\n   */\n\n\n  var _dayOfYearToTimeStamp = function _dayOfYearToTimeStamp(dayOfYear) {\n    var year = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date().getFullYear();\n    var yearStart = new Date(\"1/1/\".concat(year, \" 0:0:0 Z\"));\n    var yearStartMS = yearStart.getTime();\n    return Math.floor(yearStartMS + (dayOfYear - 1) * _MS_IN_A_DAY);\n  };\n  /**\n   * Converts radians (0 to 2π) to degrees (0 to 360).\n   */\n\n\n  var _radiansToDegrees = function _radiansToDegrees(radians) {\n    return radians * (180 / Math.PI);\n  };\n  /**\n   * Converts degrees (0 to 360) to radians (0 to 2π).\n   */\n\n\n  var _degreesToRadians = function _degreesToRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  };\n  /**\n   * Determines if a pair of longitude points crosses over the antemeridian, which is a\n   * pain point for mapping software.\n   */\n\n\n  var _crossesAntemeridian = function _crossesAntemeridian(longitude1, longitude2) {\n    if (!longitude1 || !longitude2) return false;\n\n    var isLong1Positive = _isPositive(longitude1);\n\n    var isLong2Positive = _isPositive(longitude2);\n\n    var haveSameSigns = isLong1Positive === isLong2Positive;\n    if (haveSameSigns) return false; // Signs don't match, so check if we're reasonably near the antemeridian (just to be sure it's\n    // not the prime meridian).\n\n    var isNearAntemeridian = Math.abs(longitude1) > 100;\n    return isNearAntemeridian;\n  };\n  /**\n   * Note: TLEs have a year 2000 style problem in 2057, because they only represent years in 2\n   * characters.  This function doesn't account for that problem.\n   *\n   * Example:\n   * _getFullYear(98);\n   * -> 1998\n   *\n   * @param {Number} twoDigitYear\n   */\n\n\n  function _getFullYear(twoDigitYear) {\n    var twoDigitYearInt = parseInt(twoDigitYear, 10);\n    return twoDigitYearInt < 100 && twoDigitYearInt > 56 ? twoDigitYearInt + 1900 : twoDigitYearInt + 2000;\n  }\n  /**\n   * Gets a piece of data directly from a TLE line string, and attempts to parse it based on\n   * data format.\n   *\n   * @param {Object} parsedTLE\n   * @param {(1|2)} lineNumber TLE line number.\n   * @param {Object} definition From line-1-definitions or line-2-definitions.\n   */\n\n\n  function getFromTLE(parsedTLE, lineNumber, definition) {\n    var name = parsedTLE.name,\n        tle = parsedTLE.tle;\n    var line = lineNumber === 1 ? tle[0] : tle[1];\n    var start = definition.start,\n        length = definition.length,\n        type = definition.type;\n    var val = line.substr(start, length);\n    var output;\n\n    switch (type) {\n      case _TLE_DATA_TYPES._INT:\n        output = parseInt(val, 10);\n        break;\n\n      case _TLE_DATA_TYPES._FLOAT:\n        output = parseFloat(val);\n        break;\n\n      case _TLE_DATA_TYPES._DECIMAL_ASSUMED:\n        output = parseFloat(\"0.\".concat(val));\n        break;\n\n      case _TLE_DATA_TYPES._DECIMAL_ASSUMED_E:\n        output = _decimalAssumedEToFloat(val);\n        break;\n\n      case _TLE_DATA_TYPES._CHAR:\n      default:\n        output = val.trim();\n        break;\n    }\n\n    return output;\n  }\n\n  var _ERRORS = {\n    _TYPE: function _TYPE() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var expected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var got = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n      return \"\".concat(context, \" must be of type [\").concat(expected.join(\", \"), \"], but got \").concat(got, \".\");\n    },\n    _NOT_PARSED_OBJECT: \"Input object is malformed (should have name and tle properties).\"\n  };\n\n  function isTLEObj(obj) {\n    return typeof obj === _DATA_TYPES._OBJECT && obj.name && obj.tle && getType(obj.tle) === _DATA_TYPES._ARRAY && obj.tle.length === 2;\n  } // For TLE parsing memoization.\n\n\n  var tleCache = {};\n  /**\n   * Converts string and array TLE formats into a \"parsed\" TLE in a consistent object format.\n   * Accepts 2 and 3-line (with satellite name) TLE variants in string (\\n-delimited) and array\n   * forms.\n   *\n   * Example:\n   * parseTLE(`ISS (ZARYA)\n   * 1 25544U 98067A   19285.67257269  .00001247  00000-0  29690-4 0  9993\n   * 2 25544  51.6439 138.6866 0007415 141.2524 326.3533 15.50194187193485`);\n   * ->\n   * {\n   *   name: 'ISS (ZARYA)',\n   *   tle: [\n   *     '1 25544U 98067A   19285.67257269  .00001247  00000-0  29690-4 0  9993',\n   *     '2 25544  51.6439 138.6866 0007415 141.2524 326.3533 15.50194187193485'\n   *   ]\n   * }\n   */\n\n  var acceptedTLETypes = [_DATA_TYPES._ARRAY, _DATA_TYPES._STRING, _DATA_TYPES._OBJECT];\n\n  function parseTLE(sourceTLE) {\n    var type = getType(sourceTLE);\n    var output = {};\n    var tleArray = [];\n    var alreadyParsed = isTLEObj(sourceTLE);\n\n    if (alreadyParsed) {\n      // This TLE has already been parsed, so there's nothing left to do.\n      return sourceTLE;\n    }\n\n    var isUnexpectedObject = !alreadyParsed && type === _DATA_TYPES._OBJECT;\n\n    if (isUnexpectedObject) {\n      // TLE is in an unexpected object format.\n      throw new Error(_ERRORS._NOT_PARSED_OBJECT);\n    } // Note: only strings and arrays will make it past this point.\n    // Check if the TLE exists in the cache.\n\n\n    var cacheKey = type === _DATA_TYPES._ARRAY ? sourceTLE[0] : sourceTLE;\n\n    if (tleCache[cacheKey]) {\n      return tleCache[cacheKey];\n    }\n\n    if (!acceptedTLETypes.includes(type)) {\n      throw new Error(_ERRORS._TYPE(\"Source TLE\", acceptedTLETypes, type));\n    } // Convert to array.\n\n\n    if (type === _DATA_TYPES._STRING) {\n      tleArray = sourceTLE.split(\"\\n\");\n    } else if (type === _DATA_TYPES._ARRAY) {\n      // Already an array, so make a copy so we don't mutate the input.\n      tleArray = Array.from(sourceTLE);\n    } // 3-line variant: remove name from array for consistency.\n\n\n    if (tleArray.length === 3) {\n      var name = tleArray[0].trim();\n      tleArray = tleArray.slice(1); // Preserve original name string for use in the getSatelliteName() getter.\n\n      output.name = name;\n    }\n\n    output.tle = tleArray.map(function (line) {\n      return line.trim();\n    }); // Update cache.\n\n    tleCache[cacheKey] = output;\n    return output;\n  }\n  /**\n   * Determines the checksum for a single line of a TLE.\n   *\n   * Checksum = modulo 10 of sum of all numbers (including line number) + 1 for each negative\n   * sign (-).  Everything else is ignored.\n   */\n\n\n  function computeChecksum(tleLineStr) {\n    var charArr = tleLineStr.split(\"\"); // Remove trailing checksum.\n\n    charArr.splice(charArr.length - 1, 1);\n\n    if (charArr.length === 0) {\n      throw new Error(\"Character array empty!\", tleLineStr);\n    }\n\n    var checksum = charArr.reduce(function (sum, val) {\n      var parsedVal = parseInt(val, 10);\n      var parsedSum = parseInt(sum, 10);\n\n      if (Number.isInteger(parsedVal)) {\n        return parsedSum + parsedVal;\n      }\n\n      if (val === \"-\") {\n        return parsedSum + 1;\n      }\n\n      return parsedSum;\n    });\n    return checksum % 10;\n  }\n\n  function lineNumberIsValid(tleObj, lineNumber) {\n    var tle = tleObj.tle;\n    return lineNumber === parseInt(tle[lineNumber - 1][0], 10);\n  }\n\n  function checksumIsValid(tleObj, lineNumber) {\n    var tle = tleObj.tle;\n    var tleLine = tle[lineNumber - 1];\n    var checksumInTLE = parseInt(tleLine[tleLine.length - 1], 10);\n    var computedChecksum = computeChecksum(tle[lineNumber - 1]);\n    return computedChecksum === checksumInTLE;\n  }\n  /**\n   * Determines if a TLE is structurally valid.\n   */\n\n\n  function isValidTLE(rawTLE) {\n    var tleObj;\n\n    try {\n      tleObj = parseTLE(rawTLE);\n    } catch (e) {\n      return false;\n    } // Line number checks.\n\n\n    var line1NumberIsValid = lineNumberIsValid(tleObj, 1);\n    var line2NumberIsValid = lineNumberIsValid(tleObj, 2);\n\n    if (!line1NumberIsValid || !line2NumberIsValid) {\n      return false;\n    } // Checksums\n\n\n    var line1ChecksumIsValid = checksumIsValid(tleObj, 1);\n    var line2ChecksumIsValid = checksumIsValid(tleObj, 2);\n\n    if (!line1ChecksumIsValid || !line2ChecksumIsValid) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Two-Line Element Set (TLE) format definitions, Line 1\n   * See https://en.wikipedia.org/wiki/Two-line_element_set and https://celestrak.com/columns/v04n03/\n   */\n\n  /* TLE line number. Will always return 1 for valid TLEs. */\n\n\n  var lineNumber1 = {\n    start: 0,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * NORAD satellite catalog number (e.g. Sputnik's rocket was number 00001).\n   * See https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n   *\n   * Range: 0 to 99999\n   * Example: 25544\n   */\n\n  var catalogNumber1 = {\n    start: 2,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Satellite classification.\n   * 'U' = unclassified\n   * 'C' = classified\n   * 'S' = secret\n   *\n   * Example: 'U'\n   */\n\n  var classification = {\n    start: 7,\n    length: 1,\n    type: _TLE_DATA_TYPES._CHAR\n  };\n  /**\n   * International Designator (COSPAR ID): Last 2 digits of launch year.\n   * 57 to 99 = 1900s, 00-56 = 2000s\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: 00 to 99\n   * Example: 98\n   */\n\n  var intDesignatorYear = {\n    start: 9,\n    length: 2,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * International Designator (COSPAR ID): Launch number of the year.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: 1 to 999\n   * Example: 67\n   */\n\n  var intDesignatorLaunchNumber = {\n    start: 11,\n    length: 3,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * International Designator  (COSPAR ID): Piece of the launch.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: A to ZZZ\n   * Example: 'A'\n   */\n\n  var intDesignatorPieceOfLaunch = {\n    start: 14,\n    length: 3,\n    type: _TLE_DATA_TYPES._CHAR\n  };\n  /**\n   * Year when the TLE was generated (TLE epoch), last two digits.\n   *\n   * Range: 00 to 99\n   * Example: 17\n   */\n\n  var epochYear = {\n    start: 18,\n    length: 2,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Fractional day of the year when the TLE was generated (TLE epoch).\n   *\n   * Range: 1 to 365.99999999\n   * Example: 206.18396726\n   */\n\n  var epochDay = {\n    start: 20,\n    length: 12,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * First Time Derivative of the Mean Motion divided by two.  Defines how mean motion changes\n   * from day to day, so TLE propagators can still be used to make reasonable guesses when\n   * times are distant from the original TLE epoch.\n   *\n   * Units: Orbits / day ^ 2\n   * Example: 0.00001961\n   */\n\n  var firstTimeDerivative = {\n    start: 33,\n    length: 11,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Second Time Derivative of Mean Motion divided by six (decimal point assumed). Measures rate\n   * of change in the Mean Motion Dot so software can make reasonable guesses when times are\n   * distant from the original TLE epoch.\n   *\n   * Usually zero, unless the satellite is manuevering or in a decaying orbit.\n   *\n   * Units: Orbits / day ^ 3.\n   * Example: 0 ('00000-0' in the original TLE [= 0.00000 * 10 ^ 0])\n   */\n\n  var secondTimeDerivative = {\n    start: 44,\n    length: 8,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED_E\n  };\n  /**\n   * BSTAR drag term (decimal point assumed).  Estimates the effects of\n   * atmospheric drag on the satellite's motion.\n   *\n   * Units: EarthRadii ^ -1\n   * Example: 0.000036771 ('36771-4' in the original TLE [= 0.36771 * 10 ^ -4])\n   */\n\n  var bstarDrag = {\n    start: 53,\n    length: 8,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED_E\n  };\n  /**\n   * Private value - used by Air Force Space Command to reference the orbit model used to\n   * generate the TLE.  Will always be seen as zero externally (e.g. by \"us\", unless you are\n   * \"them\" - in which case, hello!).\n   *\n   * Example: 0\n   */\n\n  var orbitModel = {\n    start: 62,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * TLE element set number, incremented for each new TLE generated. 999 seems to mean the TLE\n   * has maxed out.\n   *\n   * Range: Technically 1 to 9999, though in practice the maximum number seems to be 999.\n   * Example: 999\n   */\n\n  var tleSetNumber = {\n    start: 64,\n    length: 4,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /*\n   * TLE line 1 checksum (modulo 10), for verifying the integrity of this line of the TLE.\n   *\n   * Range: 0 to 9\n   * Example: 3\n   */\n\n  var checksum1 = {\n    start: 68,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * General helper to get a piece of data from the first line of a TLE.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Object} definition From `line-1-definitions.js`\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFromLine1(tle, definition) {\n    var isTLEParsed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var parsedTLE = isTLEParsed ? tle : parseTLE(tle);\n    return getFromTLE(parsedTLE, 1, definition);\n  }\n  /**\n   * Returns the line number from line 1.  Should always return \"1\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getLineNumber1(tle, isTLEParsed) {\n    return getFromLine1(tle, lineNumber1, isTLEParsed);\n  }\n  /**\n   * Returns the Space Catalog Number (aka NORAD Catalog Number).\n   * See https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getCatalogNumber1(tle, isTLEParsed) {\n    return getFromLine1(tle, catalogNumber1, isTLEParsed);\n  }\n  /**\n   * Returns the satellite classification.  For example, an unclassified satellite will return `U`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getClassification(tle, isTLEParsed) {\n    return getFromLine1(tle, classification, isTLEParsed);\n  }\n  /**\n   * Returns the launch year (last two digits), which makes up part of the COSPAR id\n   * (international designator).  For example, a satellite launched in 1999 will return \"99\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getIntDesignatorYear(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorYear, isTLEParsed);\n  }\n  /**\n   * Returns the launch number of the year, which makes up part of the COSPAR id\n   * (international designator).  For example, the 50th launch of the year will return \"50\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getIntDesignatorLaunchNumber(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorLaunchNumber, isTLEParsed);\n  }\n  /**\n   * Returns the piece of the launch, which makes up part of the COSPAR id (international designator).\n   * For example, the first piece of the launch will return \"A\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getIntDesignatorPieceOfLaunch(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorPieceOfLaunch, isTLEParsed);\n  }\n  /**\n   * Returns the TLE epoch year (last two digits) when the TLE was generated.  For example, a TLE\n   * generated in 2022 will return `22`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getEpochYear(tle, isTLEParsed) {\n    return getFromLine1(tle, epochYear, isTLEParsed);\n  }\n  /**\n   * Returns the TLE epoch day of the year (day of year with fractional portion of the day) when the\n   * TLE was generated.  For example, a TLE generated on January 1 will return something like\n   * `1.18396726`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getEpochDay(tle, isTLEParsed) {\n    return getFromLine1(tle, epochDay, isTLEParsed);\n  }\n  /**\n   * First Time Derivative of the Mean Motion divided by two, measured in orbits per day per day\n   * (orbits/day2). Defines how mean motion changes from day to day, so TLE propagators can still be\n   * used to make reasonable guesses when distant from the original TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getFirstTimeDerivative(tle, isTLEParsed) {\n    return getFromLine1(tle, firstTimeDerivative, isTLEParsed);\n  }\n  /**\n   * Second Time Derivative of Mean Motion divided by six, measured in orbits per day per day per day\n   * (orbits/day3). Similar to the first time derivative, it measures rate of change in the Mean\n   * Motion Dot so software can make reasonable guesses when distant from the original TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Motion and http://castor2.ca/03_Mechanics/03_TLE/Mean_Mot_Dot.html\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getSecondTimeDerivative(tle, isTLEParsed) {\n    return getFromLine1(tle, secondTimeDerivative, isTLEParsed);\n  }\n  /**\n   * BSTAR drag term. This estimates the effects of atmospheric drag on the satellite's motion.\n   * See https://en.wikipedia.org/wiki/BSTAR\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getBstarDrag(tle, isTLEParsed) {\n    return getFromLine1(tle, bstarDrag, isTLEParsed);\n  }\n  /**\n   * Private value - used by Air Force Space Command to reference the orbit model used to generate the\n   * TLE (e.g. SGP, SGP4).  Distributed TLES will always return `0` for this value.  Note that all\n   * distributed TLEs are generated with SGP4/SDP4.\n   * See https://celestrak.com/columns/v04n03/\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getOrbitModel(tle, isTLEParsed) {\n    return getFromLine1(tle, orbitModel, isTLEParsed);\n  }\n  /**\n   * TLE element set number, incremented for each new TLE generated since launch. 999 seems to mean\n   * the TLE has maxed out.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getTleSetNumber(tle, isTLEParsed) {\n    return getFromLine1(tle, tleSetNumber, isTLEParsed);\n  }\n  /**\n   * TLE line 1 checksum (modulo 10), for verifying the integrity of this line of the TLE. Note that\n   * letters, blanks, periods, and plus signs are counted as 0, while minus signs are counted as 1.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getChecksum1(tle, isTLEParsed) {\n    return getFromLine1(tle, checksum1, isTLEParsed);\n  }\n  /**\n   * Two-Line Element Set (TLE) format definitions, Line 2\n   * See https://en.wikipedia.org/wiki/Two-line_element_set and https://celestrak.com/columns/v04n03/\n   */\n\n  /* TLE line number. Will always return 2 for valid TLEs. */\n\n\n  var lineNumber2 = {\n    start: 0,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * NORAD satellite catalog number (Sputnik's rocket was 00001).  Should match the satellite\n   * number on line 1.\n   *\n   * Range: 0 to 99999\n   * Example: 25544\n   */\n\n  var catalogNumber2 = {\n    start: 2,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a\n   * prograde orbit and 90 to 180 degrees is a retrograde orbit.\n   *\n   * Units: degrees\n   * Range: 0 to 180\n   * Example: 51.6400\n   */\n\n  var inclination = {\n    start: 8,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Right ascension of the ascending node in degrees. Essentially, this is the angle of the\n   * satellite as it crosses northward (ascending) across the Earth's equator (equatorial\n   * plane).\n   *\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 208.9163\n   */\n\n  var rightAscension = {\n    start: 17,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Orbital eccentricity, decimal point assumed. All artifical Earth satellites have an\n   * eccentricity between 0 (perfect circle) and 1 (parabolic orbit).\n   *\n   * Range: 0 to 1\n   * Example: 0.0006317 (`0006317` in the original TLE)\n   */\n\n  var eccentricity = {\n    start: 26,\n    length: 7,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED\n  };\n  /**\n   * Argument of perigee. See https://en.wikipedia.org/wiki/Argument_of_perigee\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 69.9862\n   */\n\n  var perigee = {\n    start: 34,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Mean anomaly. Indicates where the satellite was located within its orbit at the time of the\n   * TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Anomaly\n   *\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 25.2906\n   */\n\n  var meanAnomaly = {\n    start: 43,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Revolutions around the Earth per day (mean motion).\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * Range: 0 to 17 (theoretically)\n   * Example: 15.54225995\n   */\n\n  var meanMotion = {\n    start: 52,\n    length: 11,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Total satellite revolutions when this TLE was generated. This number seems to roll over\n   * (e.g. 99999 -> 0).\n   *\n   * Range: 0 to 99999\n   * Example: 6766\n   */\n\n  var revNumberAtEpoch = {\n    start: 63,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /*\n   * TLE line 2 checksum (modulo 10), for verifying the integrity of this line of the TLE.\n   *\n   * Range: 0 to 9\n   * Example: 0\n   */\n\n  var checksum2 = {\n    start: 68,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * General helper to get a piece of data from the second line of a TLE.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Object} definition From `line-1-definitions.js`\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFromLine2(tle, definition) {\n    var isTLEParsed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var parsedTLE = isTLEParsed ? tle : parseTLE(tle);\n    return getFromTLE(parsedTLE, 2, definition);\n  }\n  /**\n   * Returns the line number from line 2.  Should always return \"2\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getLineNumber2(tle, isTLEParsed) {\n    return getFromLine2(tle, lineNumber2, isTLEParsed);\n  }\n  /**\n   * Returns the line number from line 1.  Should always return \"1\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getCatalogNumber2(tle, isTLEParsed) {\n    return getFromLine2(tle, catalogNumber2, isTLEParsed);\n  }\n  /**\n   * Returns the inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a\n   * prograde orbit and 90 to 180 degrees is a retrograde orbit.\n   * See https://en.wikipedia.org/wiki/Orbital_inclination\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getInclination(tle, isTLEParsed) {\n    return getFromLine2(tle, inclination, isTLEParsed);\n  }\n  /**\n   * Returns the right ascension of the ascending node in degrees. Essentially, this is the angle of\n   * the satellite as it crosses northward (ascending) across the Earth's equator (equatorial plane).\n   * See https://en.wikipedia.org/wiki/Right_ascension_of_the_ascending_node\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getRightAscension(tle, isTLEParsed) {\n    return getFromLine2(tle, rightAscension, isTLEParsed);\n  }\n  /**\n   * Returns the orbital eccentricity. All artificial Earth satellites have an eccentricity between 0\n   * (perfect circle) and 1 (parabolic orbit).\n   * See https://en.wikipedia.org/wiki/Orbital_eccentricity\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getEccentricity(tle, isTLEParsed) {\n    return getFromLine2(tle, eccentricity, isTLEParsed);\n  }\n  /**\n   * Returns the argument of perigee.\n   * See https://en.wikipedia.org/wiki/Argument_of_perigee\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getPerigee(tle, isTLEParsed) {\n    return getFromLine2(tle, perigee, isTLEParsed);\n  }\n  /**\n   * Returns the Mean Anomaly. Indicates where the satellite was located within its orbit at the time\n   * of the TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Anomaly\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getMeanAnomaly(tle, isTLEParsed) {\n    return getFromLine2(tle, meanAnomaly, isTLEParsed);\n  }\n  /**\n   * Returns the revolutions around the Earth per day (mean motion).\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getMeanMotion(tle, isTLEParsed) {\n    return getFromLine2(tle, meanMotion, isTLEParsed);\n  }\n  /**\n   * Returns the total satellite revolutions when this TLE was generated. This number seems to roll\n   * over (e.g. 99999 -> 0).\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getRevNumberAtEpoch(tle, isTLEParsed) {\n    return getFromLine2(tle, revNumberAtEpoch, isTLEParsed);\n  }\n  /**\n   * TLE line 2 checksum (modulo 10), for verifying the integrity of this line of the TLE. Note that\n   * letters, blanks, periods, and plus signs are counted as 0, while minus signs are counted as 1.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n\n  function getChecksum2(tle, isTLEParsed) {\n    return getFromLine2(tle, checksum2, isTLEParsed);\n  }\n  /**\n   * Determines COSPAR ID.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   */\n\n\n  function getCOSPAR(tle, tleIsParsed) {\n    var partialYear = getIntDesignatorYear(tle, tleIsParsed);\n\n    var fullYear = _getFullYear(partialYear);\n\n    var launchNum = getIntDesignatorLaunchNumber(tle, tleIsParsed);\n    var launchNumWithPadding = launchNum.toString().padStart(3, 0);\n    var launchPiece = getIntDesignatorPieceOfLaunch(tle, tleIsParsed);\n    return \"\".concat(fullYear, \"-\").concat(launchNumWithPadding).concat(launchPiece);\n  }\n  /**\n   * Determines the name of a satellite, if present in the first line of a 3-line TLE.  If not found,\n   * returns \"Unknown\" by default, or the COSPAR id when fallbackToCOSPAR is true.\n   *\n   * Example:\n   * getSatelliteName(tleStr);\n   * -> 'ISS (ZARYA)'\n   *\n   * @param {String|Array} rawTLE Input TLE.\n   * @param {Boolean} fallbackToCOSPAR Returns COSPAR id when satellite name isn't found.\n   */\n\n\n  function getSatelliteName(rawTLE) {\n    var fallbackToCOSPAR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var parsedTLE = parseTLE(rawTLE);\n    var name = parsedTLE.name;\n\n    if (fallbackToCOSPAR) {\n      return name || getCOSPAR(parsedTLE, true);\n    } else {\n      return name || \"Unknown\";\n    }\n  }\n  /**\n   * Determines the Unix timestamp (in ms) of a TLE epoch (the time a TLE was generated).\n   *\n   * Example:\n   * getEpochTimestamp(tleStr);\n   * -> 1500956694771\n   */\n\n\n  function getEpochTimestamp(rawTLE) {\n    var epochDay = getEpochDay(rawTLE);\n    var epochYear = getEpochYear(rawTLE);\n    return _dayOfYearToTimeStamp(epochDay, epochYear);\n  }\n  /**\n   * Determines the average amount of milliseconds in one orbit.\n   */\n\n\n  function getAverageOrbitTimeMS(tle) {\n    return parseInt(_MS_IN_A_DAY / getMeanMotion(tle), 10);\n  }\n  /**\n   * Determines the average amount of minutes in one orbit.\n   */\n\n\n  function getAverageOrbitTimeMins(tle) {\n    return getAverageOrbitTimeMS(tle) / _MS_IN_A_MINUTE;\n  }\n  /**\n   * Determines the average amount of seconds in one orbit.\n   */\n\n\n  function getAverageOrbitTimeS(tle) {\n    return getAverageOrbitTimeMS(tle) / _MS_IN_A_SECOND;\n  }\n\n  var _SAT_REC_ERRORS = {\n    _DEFAULT: \"Problematic TLE with unknown error.\",\n    1: \"Mean elements, ecc >= 1.0 or ecc < -0.001 or a < 0.95 er\",\n    2: \"Mean motion less than 0.0\",\n    3: \"Pert elements, ecc < 0.0  or  ecc > 1.0\",\n    4: \"Semi-latus rectum < 0.0\",\n    5: \"Epoch elements are sub-orbital\",\n    6: \"Satellite has decayed\"\n  };\n  var cachedSatelliteInfo = {};\n  var cachedAntemeridianCrossings = {};\n  var cachedOrbitTracks = {};\n  var cachedVisibleSatellites = {\n    slowMoving: {}\n  };\n  var cachedGroundTrack = {};\n  var caches = [cachedSatelliteInfo, cachedAntemeridianCrossings, cachedOrbitTracks, cachedVisibleSatellites, cachedGroundTrack];\n\n  function getCacheSizes() {\n    return caches.map(function (cache) {\n      return getObjLength;\n    });\n  }\n  /**\n   * Provides a way to clear up memory for long-running apps.\n   */\n\n\n  function clearCache() {\n    cachedVisibleSatellites.slowMoving = [];\n  }\n  /**\n  \t * Determines satellite position and look angles from an earth observer.\n  \t *\n  \t * Example:\n  \t * const satInfo = getSatelliteInfo(\n  \t *   tleStr,          // Satellite TLE string or array (2 or 3 line variants).\n  \t *   1501039265000,   // Unix timestamp (ms)\n  \t *   34.243889,       // Observer latitude (degrees)\n  \t *   -116.911389,     // Observer longitude (degrees)\n  \t *   0                // Observer elevation (km)\n  \t * );\n  \t *\n  \t * ->\n  \t * {\n  \t *   // satellite compass heading from observer in degrees (0 = north, 180 = south)\n  \t *   azimuth: 294.5780478624994,\n  \t *\n  \t *   // satellite elevation from observer in degrees (90 is directly overhead)\n  \t *   elevation: 81.63903620330046,\n  \t *\n  \t *   // km distance from observer to spacecraft\n  \t *   range: 406.60211015810074,\n  \t *\n  \t *   // spacecraft altitude in km\n  \t *   height: 402.9082788620108,\n   \t *   // spacecraft latitude in degrees\n  \t *   lat: 34.45112876592785,\n   \t *   // spacecraft longitude in degrees\n  \t *   lng: -117.46176597710809,\n  \t *\n  \t *   // spacecraft velocity in km/s\n  \t *   velocity: 7.675627442183371\n  \t * }\n  \t */\n\n\n  function getSatelliteInfo(rawTLE, rawTimestamp, observerLat, observerLng, observerHeight) {\n    var timestamp = rawTimestamp || Date.now();\n\n    var _parseTLE = parseTLE(rawTLE),\n        tle = _parseTLE.tle;\n\n    var defaultObserverPosition = {\n      lat: 36.9613422,\n      lng: -122.0308,\n      height: 0.37\n    };\n    var obsLat = observerLat || defaultObserverPosition.lat;\n    var obsLng = observerLng || defaultObserverPosition.lng;\n    var obsHeight = observerHeight || defaultObserverPosition.height; // Memoization\n\n    var cacheKey = \"\".concat(tle[0], \"-\").concat(timestamp, \"-\").concat(observerLat, \"-\").concat(observerLng, \"\\n-\").concat(observerHeight);\n\n    if (cachedSatelliteInfo[cacheKey]) {\n      return cachedSatelliteInfo[cacheKey];\n    } // Initialize a satellite record\n\n\n    var satrec = satellite_js.twoline2satrec(tle[0], tle[1]);\n\n    if (satrec.error) {\n      throw new Error(_SAT_REC_ERRORS[satrec.error] || _SAT_REC_ERRORS._DEFAULT);\n    }\n\n    var dateObj = new Date(timestamp); // Propagate SGP4.\n\n    var positionAndVelocity = satellite_js.propagate(satrec, dateObj); // The position_velocity result is a key-value pair of ECI coordinates.\n    // These are the base results from which all other coordinates are derived.\n\n    var positionEci = positionAndVelocity.position;\n    var velocityEci = positionAndVelocity.velocity; // Set the observer position (in radians).\n\n    var observerGd = {\n      latitude: _degreesToRadians(obsLat),\n      longitude: _degreesToRadians(obsLng),\n      height: obsHeight\n    }; // Get GMST for some coordinate transforms.\n    // http://en.wikipedia.org/wiki/Sidereal_time#Definition\n\n    var gmst = satellite_js.gstime(dateObj); // Get ECF, Geodetic, Look Angles, and Doppler Factor.\n\n    var positionEcf = satellite_js.eciToEcf(positionEci, gmst);\n    var positionGd = satellite_js.eciToGeodetic(positionEci, gmst);\n    var lookAngles = satellite_js.ecfToLookAngles(observerGd, positionEcf);\n    var velocityKmS = Math.sqrt(Math.pow(velocityEci.x, 2) + Math.pow(velocityEci.y, 2) + Math.pow(velocityEci.z, 2)); // Azimuth: is simply the compass heading from the observer's position.\n\n    var azimuth = lookAngles.azimuth,\n        elevation = lookAngles.elevation,\n        rangeSat = lookAngles.rangeSat; // Geodetic coords are accessed via `longitude`, `latitude`, `height`.\n\n    var longitude = positionGd.longitude,\n        latitude = positionGd.latitude,\n        height = positionGd.height;\n    var output = {\n      lng: satellite_js.degreesLong(longitude),\n      lat: satellite_js.degreesLat(latitude),\n      elevation: _radiansToDegrees(elevation),\n      azimuth: _radiansToDegrees(azimuth),\n      range: rangeSat,\n      height: height,\n      velocity: velocityKmS\n    }; // Memoization\n\n    cachedSatelliteInfo[cacheKey] = output;\n    return output;\n  }\n  /**\n   * Determines if the last antemeridian crossing has been cached.  If it has, the time (in ms)\n   * is returned, otherwise it returns false.\n   */\n\n\n  function getCachedLastAntemeridianCrossingTimeMS(tleObj, timeMS) {\n    var tle = tleObj.tle;\n    var orbitLengthMS = getAverageOrbitTimeMins(tle) * 60 * 1000;\n    var tleStr = tle[0].substr(0, 30);\n    var cachedCrossingTimes = cachedAntemeridianCrossings[tleStr];\n    if (!cachedCrossingTimes) return false;\n    if (cachedCrossingTimes === -1) return cachedCrossingTimes;\n    var cachedTime = cachedCrossingTimes.filter(function (val) {\n      if (typeof val === \"object\" && val.tle === tle) return -1;\n      var diff = timeMS - val;\n      var isDiffPositive = diff > 0;\n      var isWithinOrbit = isDiffPositive && diff < orbitLengthMS;\n      return isWithinOrbit;\n    });\n    return cachedTime[0] || false;\n  }\n  /**\n   * Determines the last time the satellite crossed the antemeridian.  For mapping convenience\n   * and to avoid headaches, we want to avoid plotting ground tracks that cross the antemeridian.\n   */\n\n\n  function getLastAntemeridianCrossingTimeMS(tle, timeMS) {\n    var parsedTLE = parseTLE(tle);\n    var tleArr = parsedTLE.tle;\n    var cachedVal = getCachedLastAntemeridianCrossingTimeMS(parsedTLE, timeMS);\n\n    if (cachedVal) {\n      return cachedVal;\n    }\n\n    var time = timeMS || Date.now();\n    var step = 1000 * 60 * 10;\n    var curLngLat = [];\n    var lastLngLat = [];\n    var curTimeMS = time;\n    var didCrossAntemeridian = false;\n    var tries = 0;\n    var isDone = false;\n    var maxTries = 1000;\n\n    while (!isDone) {\n      curLngLat = getLngLat(tleArr, curTimeMS);\n\n      var _curLngLat = curLngLat,\n          _curLngLat2 = _slicedToArray(_curLngLat, 2),\n          curLng = _curLngLat2[0],\n          curLat = _curLngLat2[1];\n\n      didCrossAntemeridian = _crossesAntemeridian(lastLngLat[0], curLng);\n\n      if (didCrossAntemeridian) {\n        // Back up a bit, then keep halving the step increment till we get close enough.\n        curTimeMS += step;\n        step = step > 20000 ? 20000 : step / 2;\n      } else {\n        curTimeMS -= step;\n        lastLngLat = curLngLat;\n      }\n\n      isDone = step < 500 || tries >= maxTries;\n      tries++;\n    }\n\n    var couldNotFindCrossing = tries - 1 === maxTries;\n    var crossingTime = couldNotFindCrossing ? -1 : parseInt(curTimeMS, 10);\n    var tleStr = tleArr[0];\n\n    if (!cachedAntemeridianCrossings[tleStr]) {\n      cachedAntemeridianCrossings[tleStr] = [];\n    }\n\n    if (couldNotFindCrossing) {\n      cachedAntemeridianCrossings[tleStr] = -1;\n    } else {\n      cachedAntemeridianCrossings[tleStr].push(crossingTime);\n    }\n\n    return crossingTime;\n  }\n  /**\n   * Determines current satellite position, or position at time of timestamp (optional).\n   *\n   * @param {Array|String} tle\n   * @param {Number} optionalTimestamp Unix timestamp in milliseconds.\n   */\n\n\n  function getLatLngObj(tle) {\n    var optionalTimestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();\n\n    var _getSatelliteInfo = getSatelliteInfo(tle, optionalTimestamp),\n        lat = _getSatelliteInfo.lat,\n        lng = _getSatelliteInfo.lng;\n\n    return {\n      lat: lat,\n      lng: lng\n    };\n  }\n  /**\n   * Determines current satellite position, or position at time of timestamp (optional).\n   *\n   * @param {Array|String} tle\n   * @param {Number} optionalTimestamp Unix timestamp in milliseconds.\n   */\n\n\n  function getLngLat(tle) {\n    var optionalTimestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();\n\n    var _getSatelliteInfo2 = getSatelliteInfo(tle, optionalTimestamp),\n        lat = _getSatelliteInfo2.lat,\n        lng = _getSatelliteInfo2.lng;\n\n    return [lng, lat];\n  }\n  /**\n   * Determines the position of the satellite at the time the TLE was generated.\n   *\n   * @param {Array|String} tle\n   */\n\n\n  function getLngLatAtEpoch(tle) {\n    return getLngLat(tle, getEpochTimestamp(tle));\n  } // TODO: cache geosync and erroring satellites and don't recompute on next pass.\n\n\n  function getVisibleSatellites(_ref) {\n    var observerLat = _ref.observerLat,\n        observerLng = _ref.observerLng,\n        _ref$observerHeight = _ref.observerHeight,\n        observerHeight = _ref$observerHeight === void 0 ? 0 : _ref$observerHeight,\n        _ref$tles = _ref.tles,\n        tles = _ref$tles === void 0 ? [] : _ref$tles,\n        _ref$elevationThresho = _ref.elevationThreshold,\n        elevationThreshold = _ref$elevationThresho === void 0 ? 0 : _ref$elevationThresho,\n        _ref$timestampMS = _ref.timestampMS,\n        timestampMS = _ref$timestampMS === void 0 ? Date.now() : _ref$timestampMS;\n    return tles.reduce(function (visibleSats, tleArr, index) {\n      // Don't waste time reprocessing geosync.\n      var cacheKey = tleArr[1];\n      var cachedVal = cachedVisibleSatellites.slowMoving[cacheKey];\n\n      if (cachedVal) {\n        var _info = cachedVal.info;\n        var cachedElevation = _info.elevation;\n        return cachedElevation >= elevationThreshold ? visibleSats.concat(cachedVal) : visibleSats;\n      }\n\n      var info;\n\n      try {\n        info = getSatelliteInfo(tleArr, timestampMS, observerLat, observerLng, observerHeight);\n      } catch (e) {\n        // Don't worry about decayed sats, just move on.\n        // TODO cache error\n        return visibleSats;\n      }\n\n      var _info2 = info,\n          elevation = _info2.elevation,\n          velocity = _info2.velocity,\n          range = _info2.range;\n      var isSlowMoving = velocity / range < 0.001;\n\n      if (isSlowMoving) {\n        cachedVisibleSatellites.slowMoving[cacheKey] = {\n          tleArr: tleArr,\n          info: info\n        };\n      }\n\n      return elevation >= elevationThreshold ? visibleSats.concat({\n        tleArr: tleArr,\n        info: info\n      }) : visibleSats;\n    }, []);\n  }\n\n  function getNextPosition(tleArr, startTimeMS, stepMS) {\n    var curTimeMS;\n    return _regeneratorRuntime.wrap(function getNextPosition$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            curTimeMS = startTimeMS - stepMS;\n\n          case 1:\n            if (!true) {\n              _context.next = 7;\n              break;\n            }\n\n            curTimeMS += stepMS;\n            _context.next = 5;\n            return {\n              curTimeMS: curTimeMS,\n              lngLat: getLngLat(tleArr, curTimeMS)\n            };\n\n          case 5:\n            _context.next = 1;\n            break;\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _marked);\n  }\n\n  function sleep(ms) {\n    return new Promise(function (resolve) {\n      return setTimeout(resolve, ms);\n    });\n  }\n  /**\n   * Generates an array of lng/lat pairs representing a ground track (orbit track), starting\n   * from startTimeMS and continuing until just before crossing the antemeridian, which is considered the end\n   * of the orbit for convenience.\n   *\n   * Consider pairing this with getLastAntemeridianCrossingTimeMS() to create a full orbit path (see usage\n   * in getGroundTracks()).\n   */\n\n\n  function getOrbitTrack(_ref2) {\n    var tle = _ref2.tle,\n        _ref2$startTimeMS = _ref2.startTimeMS,\n        startTimeMS = _ref2$startTimeMS === void 0 ? Date.now() : _ref2$startTimeMS,\n        _ref2$stepMS = _ref2.stepMS,\n        stepMS = _ref2$stepMS === void 0 ? 1000 : _ref2$stepMS,\n        _ref2$sleepMS = _ref2.sleepMS,\n        sleepMS = _ref2$sleepMS === void 0 ? 0 : _ref2$sleepMS,\n        _ref2$jobChunkSize = _ref2.jobChunkSize,\n        jobChunkSize = _ref2$jobChunkSize === void 0 ? 1000 : _ref2$jobChunkSize,\n        _ref2$maxTimeMS = _ref2.maxTimeMS,\n        maxTimeMS = _ref2$maxTimeMS === void 0 ? 6000000 : _ref2$maxTimeMS,\n        _ref2$isLngLatFormat = _ref2.isLngLatFormat,\n        isLngLatFormat = _ref2$isLngLatFormat === void 0 ? true : _ref2$isLngLatFormat;\n    return new Promise( /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n        var _parseTLE2, tleArr, startS, cacheKey, generator, step, isDone, coords, lastLng, _generator$next$value, curTimeMS, lngLat, _lngLat, curLng, curLat, doesCrossAntemeridian, doesExceedTime;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _parseTLE2 = parseTLE(tle), tleArr = _parseTLE2.tle;\n                startS = (startTimeMS / 1000).toFixed();\n                cacheKey = \"\".concat(tleArr[0], \"-\").concat(startS, \"-\").concat(stepMS, \"-\").concat(isLngLatFormat);\n\n                if (!cachedOrbitTracks[cacheKey]) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                resolve(cachedOrbitTracks[cacheKey]);\n                return _context2.abrupt(\"return\");\n\n              case 6:\n                generator = getNextPosition(tleArr, startTimeMS, stepMS);\n                step = 0;\n                isDone = false;\n                coords = [];\n\n              case 10:\n                if (isDone) {\n                  _context2.next = 24;\n                  break;\n                }\n\n                _generator$next$value = generator.next().value, curTimeMS = _generator$next$value.curTimeMS, lngLat = _generator$next$value.lngLat;\n                _lngLat = _slicedToArray(lngLat, 2), curLng = _lngLat[0], curLat = _lngLat[1];\n                doesCrossAntemeridian = _crossesAntemeridian(lastLng, curLng);\n                doesExceedTime = maxTimeMS && curTimeMS - startTimeMS > maxTimeMS;\n                isDone = doesCrossAntemeridian || doesExceedTime;\n\n                if (isLngLatFormat) {\n                  coords.push(lngLat);\n                } else {\n                  coords.push([curLat, curLng]);\n                }\n\n                if (!(sleepMS && step % jobChunkSize === 0)) {\n                  _context2.next = 20;\n                  break;\n                }\n\n                _context2.next = 20;\n                return sleep(sleepMS);\n\n              case 20:\n                lastLng = curLng;\n                step++;\n                _context2.next = 10;\n                break;\n\n              case 24:\n                cachedOrbitTracks[cacheKey] = coords;\n                resolve(coords);\n\n              case 26:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x, _x2) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n  }\n  /**\n   *\n   */\n\n\n  function getOrbitTrackSync(_ref4) {\n    var tle = _ref4.tle,\n        _ref4$startTimeMS = _ref4.startTimeMS,\n        startTimeMS = _ref4$startTimeMS === void 0 ? Date.now() : _ref4$startTimeMS,\n        _ref4$stepMS = _ref4.stepMS,\n        stepMS = _ref4$stepMS === void 0 ? 1000 : _ref4$stepMS,\n        _ref4$maxTimeMS = _ref4.maxTimeMS,\n        maxTimeMS = _ref4$maxTimeMS === void 0 ? 6000000 : _ref4$maxTimeMS,\n        _ref4$isLngLatFormat = _ref4.isLngLatFormat,\n        isLngLatFormat = _ref4$isLngLatFormat === void 0 ? true : _ref4$isLngLatFormat;\n\n    var _parseTLE3 = parseTLE(tle),\n        tleArr = _parseTLE3.tle;\n\n    var startS = (startTimeMS / 1000).toFixed();\n    var cacheKey = \"\".concat(tleArr[0], \"-\").concat(startS, \"-\").concat(stepMS, \"-\").concat(isLngLatFormat);\n\n    if (cachedOrbitTracks[cacheKey]) {\n      return cachedOrbitTracks[cacheKey];\n    }\n\n    var isDone = false;\n    var coords = [];\n    var lastLng;\n    var curTimeMS = startTimeMS;\n\n    while (!isDone) {\n      var curLngLat = getLngLat(tleArr, curTimeMS);\n\n      var _curLngLat3 = _slicedToArray(curLngLat, 2),\n          curLng = _curLngLat3[0],\n          curLat = _curLngLat3[1];\n\n      var doesCrossAntemeridian = _crossesAntemeridian(lastLng, curLng);\n\n      var doesExceedTime = maxTimeMS && curTimeMS - startTimeMS > maxTimeMS;\n      isDone = doesCrossAntemeridian || doesExceedTime;\n\n      if (isLngLatFormat) {\n        coords.push(curLngLat);\n      } else {\n        coords.push([curLat, curLng]);\n      }\n\n      lastLng = curLng;\n      curTimeMS += stepMS;\n    }\n\n    cachedOrbitTracks[cacheKey] = coords;\n    return coords;\n  }\n  /**\n   * Calculates three orbit arrays of latitude/longitude pairs.\n   * TODO: just calculate future orbits\n   *\n   * @param {Array|String} options.tle\n   * @param {Number} startTimeMS Unix timestamp in milliseconds.\n   * @param {Number} stepMS Time in milliseconds between points on the ground track.\n   * @param {Boolean} isLngLatFormat Formats coords in [lng, lat] order when true, [lat, lng] when false.\n   * \n   *\n   * Example:\n   * const threeOrbitsArr = await getGroundTracks({ tle: tleStr });\n   * ->\n   * [\n   *   // previous orbit\n   *   [\n   *     [ 45.85524291891481, -179.93297540317567 ],\n   *     ...\n   *   ],\n   *\n   *   // current orbit\n   *   [\n   *     [ 51.26165992503701, -179.9398612198045 ],\n   *     ...\n   *   ],\n   *\n   *   // next orbit\n   *   [\n   *     [ 51.0273714070371, -179.9190165549038 ],\n   *     ...\n   *   ]\n   * ]\n   */\n\n\n  function getGroundTracks(_ref5) {\n    var tle = _ref5.tle,\n        _ref5$startTimeMS = _ref5.startTimeMS,\n        startTimeMS = _ref5$startTimeMS === void 0 ? Date.now() : _ref5$startTimeMS,\n        _ref5$stepMS = _ref5.stepMS,\n        stepMS = _ref5$stepMS === void 0 ? 1000 : _ref5$stepMS,\n        _ref5$isLngLatFormat = _ref5.isLngLatFormat,\n        isLngLatFormat = _ref5$isLngLatFormat === void 0 ? true : _ref5$isLngLatFormat;\n    return new Promise( /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(resolve, reject) {\n        var parsedTLE, orbitTimeMS, curOrbitStartMS, foundCrossing, partialGroundTrack, lastOrbitStartMS, nextOrbitStartMS, groundTrackPromises, threeOrbitTracks;\n        return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                parsedTLE = parseTLE(tle);\n                orbitTimeMS = getAverageOrbitTimeMS(parsedTLE);\n                curOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, startTimeMS);\n                foundCrossing = curOrbitStartMS !== -1;\n\n                if (foundCrossing) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                _context3.next = 7;\n                return getOrbitTrack({\n                  tle: parsedTLE,\n                  startTimeMS: startTimeMS,\n                  stepMS: _MS_IN_A_MINUTE,\n                  maxTimeMS: _MS_IN_A_DAY / 4,\n                  isLngLatFormat: isLngLatFormat\n                });\n\n              case 7:\n                partialGroundTrack = _context3.sent;\n                resolve([partialGroundTrack]);\n                return _context3.abrupt(\"return\");\n\n              case 10:\n                lastOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, // TODO: fix this magic math\n                curOrbitStartMS - 10000);\n                nextOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, // TODO: fix this magic math\n                curOrbitStartMS + orbitTimeMS + 1000 * 60 * 30);\n                groundTrackPromises = [getOrbitTrack({\n                  tle: parsedTLE,\n                  startTimeMS: lastOrbitStartMS,\n                  stepMS: stepMS,\n                  isLngLatFormat: isLngLatFormat\n                }), getOrbitTrack({\n                  tle: parsedTLE,\n                  startTimeMS: curOrbitStartMS,\n                  stepMS: stepMS,\n                  isLngLatFormat: isLngLatFormat\n                }), getOrbitTrack({\n                  tle: parsedTLE,\n                  startTimeMS: nextOrbitStartMS,\n                  stepMS: stepMS,\n                  isLngLatFormat: isLngLatFormat\n                })];\n                _context3.next = 15;\n                return Promise.all(groundTrackPromises);\n\n              case 15:\n                threeOrbitTracks = _context3.sent;\n                resolve(threeOrbitTracks);\n\n              case 17:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x3, _x4) {\n        return _ref6.apply(this, arguments);\n      };\n    }());\n  }\n  /**\n   * Calculates three orbit arrays of latitude/longitude pairs.\n   *\n   * Example:\n   * const threeOrbitsArr = getGroundTrackSync({ tle: tleStr });\n   * ->\n   * [\n   *   // previous orbit\n   *   [\n   *     [ 45.85524291891481, -179.93297540317567 ],\n   *     ...\n   *   ],\n   *\n   *   // current orbit\n   *   [\n   *     [ 51.26165992503701, -179.9398612198045 ],\n   *     ...\n   *   ],\n   *\n   *   // next orbit\n   *   [\n   *     [ 51.0273714070371, -179.9190165549038 ],\n   *     ...\n   *   ]\n   * ]\n   */\n\n\n  function getGroundTracksSync(_ref7) {\n    var tle = _ref7.tle,\n        _ref7$stepMS = _ref7.stepMS,\n        stepMS = _ref7$stepMS === void 0 ? 1000 : _ref7$stepMS,\n        _ref7$optionalTimeMS = _ref7.optionalTimeMS,\n        optionalTimeMS = _ref7$optionalTimeMS === void 0 ? Date.now() : _ref7$optionalTimeMS,\n        _ref7$isLngLatFormat = _ref7.isLngLatFormat,\n        isLngLatFormat = _ref7$isLngLatFormat === void 0 ? true : _ref7$isLngLatFormat;\n    var parsedTLE = parseTLE(tle);\n    var tleArr = parsedTLE.tle;\n    var orbitTimeMS = getAverageOrbitTimeMS(tleArr);\n    var curOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, optionalTimeMS);\n    var foundCrossing = curOrbitStartMS !== -1;\n\n    if (!foundCrossing) {\n      // Geosync or unusual orbit, so just return a partial orbit track.\n      var partialGroundTrack = getOrbitTrackSync({\n        tle: parsedTLE,\n        startTimeMS: timeMS,\n        stepMS: _MS_IN_A_MINUTE,\n        maxTimeMS: _MS_IN_A_DAY / 4\n      });\n      return partialGroundTrack;\n    }\n\n    var lastOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, curOrbitStartMS - 10000);\n    var nextOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, curOrbitStartMS + orbitTimeMS + 1000 * 60 * 30);\n    var orbitStartTimes = [lastOrbitStartMS, curOrbitStartMS, nextOrbitStartMS];\n    var orbitLatLons = orbitStartTimes.map(function (orbitStartMS) {\n      return getOrbitTrackSync({\n        tle: parsedTLE,\n        startTimeMS: orbitStartMS,\n        stepMS: stepMS,\n        isLngLatFormat: isLngLatFormat\n      });\n    });\n    return orbitLatLons;\n  }\n  /**\n   * Determes the compass bearing from the perspective of the satellite.  Useful for 3D / pitched\n   * map perspectives.\n   *\n   * TODO: a bit buggy at extreme parts of orbits, where latitude hardly changes.\n   */\n\n\n  function getSatBearing(tle, customTimeMS) {\n    var parsedTLE = this.parseTLE(tle);\n    var timeMS = customTimeMS || Date.now();\n    var latLon1 = this.getLatLonArr(parsedTLE.arr, timeMS);\n    var latLon2 = this.getLatLonArr(parsedTLE.arr, timeMS + 10000);\n\n    var doesCrossAntemeridian = _crossesAntemeridian(latLon1[1], latLon2[1]);\n\n    if (doesCrossAntemeridian) {\n      // TODO: fix\n      return {}; // return this.getSatBearing(tle, customTimeMS + 10000);\n    }\n\n    var lat1 = _degreesToRadians(latLon1[0]);\n\n    var lat2 = _degreesToRadians(latLon2[0]);\n\n    var lon1 = _degreesToRadians(latLon1[1]);\n\n    var lon2 = _degreesToRadians(latLon2[1]);\n\n    var NS = lat1 >= lat2 ? \"S\" : \"N\";\n    var EW = lon1 >= lon2 ? \"W\" : \"E\";\n    var y = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    var degrees = _radiansToDegrees(Math.atan2(y, x));\n\n    return {\n      degrees: degrees,\n      compass: \"\".concat(NS).concat(EW)\n    };\n  }\n\n  exports.clearCache = clearCache;\n  exports.computeChecksum = computeChecksum;\n  exports.getAverageOrbitTimeMS = getAverageOrbitTimeMS;\n  exports.getAverageOrbitTimeMins = getAverageOrbitTimeMins;\n  exports.getAverageOrbitTimeS = getAverageOrbitTimeS;\n  exports.getBstarDrag = getBstarDrag;\n  exports.getCOSPAR = getCOSPAR;\n  exports.getCacheSizes = getCacheSizes;\n  exports.getCatalogNumber = getCatalogNumber1;\n  exports.getCatalogNumber1 = getCatalogNumber1;\n  exports.getCatalogNumber2 = getCatalogNumber2;\n  exports.getChecksum1 = getChecksum1;\n  exports.getChecksum2 = getChecksum2;\n  exports.getClassification = getClassification;\n  exports.getEccentricity = getEccentricity;\n  exports.getEpochDay = getEpochDay;\n  exports.getEpochTimestamp = getEpochTimestamp;\n  exports.getEpochYear = getEpochYear;\n  exports.getFirstTimeDerivative = getFirstTimeDerivative;\n  exports.getGroundTracks = getGroundTracks;\n  exports.getGroundTracksSync = getGroundTracksSync;\n  exports.getInclination = getInclination;\n  exports.getIntDesignatorLaunchNumber = getIntDesignatorLaunchNumber;\n  exports.getIntDesignatorPieceOfLaunch = getIntDesignatorPieceOfLaunch;\n  exports.getIntDesignatorYear = getIntDesignatorYear;\n  exports.getLastAntemeridianCrossingTimeMS = getLastAntemeridianCrossingTimeMS;\n  exports.getLatLngObj = getLatLngObj;\n  exports.getLineNumber1 = getLineNumber1;\n  exports.getLineNumber2 = getLineNumber2;\n  exports.getLngLatAtEpoch = getLngLatAtEpoch;\n  exports.getMeanAnomaly = getMeanAnomaly;\n  exports.getMeanMotion = getMeanMotion;\n  exports.getOrbitModel = getOrbitModel;\n  exports.getOrbitTrack = getOrbitTrack;\n  exports.getOrbitTrackSync = getOrbitTrackSync;\n  exports.getPerigee = getPerigee;\n  exports.getRevNumberAtEpoch = getRevNumberAtEpoch;\n  exports.getRightAscension = getRightAscension;\n  exports.getSatBearing = getSatBearing;\n  exports.getSatelliteInfo = getSatelliteInfo;\n  exports.getSatelliteName = getSatelliteName;\n  exports.getSecondTimeDerivative = getSecondTimeDerivative;\n  exports.getTleSetNumber = getTleSetNumber;\n  exports.getVisibleSatellites = getVisibleSatellites;\n  exports.isValidTLE = isValidTLE;\n  exports.parseTLE = parseTLE;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["C:/Users/Md. Mehrab Haque/Desktop/satellight/node_modules/tle.js/dist/tlejs.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","tlejs","satellite","satellite_js","getNextPosition","_MS_IN_A_DAY","_MS_IN_A_SECOND","_MS_IN_A_MINUTE","_TLE_DATA_TYPES","_INT","Symbol","_FLOAT","_CHAR","_DECIMAL_ASSUMED","_DECIMAL_ASSUMED_E","_DATA_TYPES","_ARRAY","_STRING","_OBJECT","_DATE","_NAN","getType","input","type","Array","isArray","Date","Number","isNaN","_isPositive","num","_getDigitCount","absVal","Math","abs","toString","length","_toLeadingDecimal","numDigits","zeroes","repeat","parseFloat","_decimalAssumedEToFloat","str","numWithAssumedLeadingDecimal","substr","leadingDecimalPoints","parseInt","float","pow","toPrecision","_dayOfYearToTimeStamp","dayOfYear","year","getFullYear","yearStart","yearStartMS","getTime","floor","_radiansToDegrees","radians","PI","_degreesToRadians","degrees","_crossesAntemeridian","longitude1","longitude2","isLong1Positive","isLong2Positive","haveSameSigns","isNearAntemeridian","_getFullYear","twoDigitYear","twoDigitYearInt","getFromTLE","parsedTLE","lineNumber","definition","name","tle","line","start","val","output","trim","_ERRORS","_TYPE","context","expected","got","join","_NOT_PARSED_OBJECT","isTLEObj","obj","tleCache","acceptedTLETypes","parseTLE","sourceTLE","tleArray","alreadyParsed","isUnexpectedObject","Error","cacheKey","includes","split","from","slice","map","computeChecksum","tleLineStr","charArr","splice","checksum","reduce","sum","parsedVal","parsedSum","isInteger","lineNumberIsValid","tleObj","checksumIsValid","tleLine","checksumInTLE","computedChecksum","isValidTLE","rawTLE","e","line1NumberIsValid","line2NumberIsValid","line1ChecksumIsValid","line2ChecksumIsValid","lineNumber1","catalogNumber1","classification","intDesignatorYear","intDesignatorLaunchNumber","intDesignatorPieceOfLaunch","epochYear","epochDay","firstTimeDerivative","secondTimeDerivative","bstarDrag","orbitModel","tleSetNumber","checksum1","getFromLine1","isTLEParsed","getLineNumber1","getCatalogNumber1","getClassification","getIntDesignatorYear","getIntDesignatorLaunchNumber","getIntDesignatorPieceOfLaunch","getEpochYear","getEpochDay","getFirstTimeDerivative","getSecondTimeDerivative","getBstarDrag","getOrbitModel","getTleSetNumber","getChecksum1","lineNumber2","catalogNumber2","inclination","rightAscension","eccentricity","perigee","meanAnomaly","meanMotion","revNumberAtEpoch","checksum2","getFromLine2","getLineNumber2","getCatalogNumber2","getInclination","getRightAscension","getEccentricity","getPerigee","getMeanAnomaly","getMeanMotion","getRevNumberAtEpoch","getChecksum2","getCOSPAR","tleIsParsed","partialYear","fullYear","launchNum","launchNumWithPadding","padStart","launchPiece","getSatelliteName","fallbackToCOSPAR","getEpochTimestamp","getAverageOrbitTimeMS","getAverageOrbitTimeMins","getAverageOrbitTimeS","_SAT_REC_ERRORS","_DEFAULT","cachedSatelliteInfo","cachedAntemeridianCrossings","cachedOrbitTracks","cachedVisibleSatellites","slowMoving","cachedGroundTrack","caches","getCacheSizes","cache","getObjLength","clearCache","getSatelliteInfo","rawTimestamp","observerLat","observerLng","observerHeight","timestamp","now","defaultObserverPosition","lat","lng","height","obsLat","obsLng","obsHeight","satrec","twoline2satrec","error","dateObj","positionAndVelocity","propagate","positionEci","position","velocityEci","velocity","observerGd","latitude","longitude","gmst","gstime","positionEcf","eciToEcf","positionGd","eciToGeodetic","lookAngles","ecfToLookAngles","velocityKmS","sqrt","x","y","z","azimuth","elevation","rangeSat","degreesLong","degreesLat","range","getCachedLastAntemeridianCrossingTimeMS","timeMS","orbitLengthMS","tleStr","cachedCrossingTimes","cachedTime","filter","diff","isDiffPositive","isWithinOrbit","getLastAntemeridianCrossingTimeMS","tleArr","cachedVal","time","step","curLngLat","lastLngLat","curTimeMS","didCrossAntemeridian","tries","isDone","maxTries","getLngLat","curLng","curLat","couldNotFindCrossing","crossingTime","push","getLatLngObj","optionalTimestamp","getLngLatAtEpoch","getVisibleSatellites","tles","elevationThreshold","timestampMS","visibleSats","index","info","cachedElevation","concat","isSlowMoving","startTimeMS","stepMS","lngLat","sleep","ms","Promise","resolve","setTimeout","getOrbitTrack","sleepMS","jobChunkSize","maxTimeMS","isLngLatFormat","reject","startS","toFixed","generator","coords","next","value","doesCrossAntemeridian","lastLng","doesExceedTime","getOrbitTrackSync","getGroundTracks","orbitTimeMS","curOrbitStartMS","foundCrossing","partialGroundTrack","lastOrbitStartMS","nextOrbitStartMS","groundTrackPromises","all","threeOrbitTracks","getGroundTracksSync","optionalTimeMS","orbitStartTimes","orbitLatLons","orbitStartMS","getSatBearing","customTimeMS","latLon1","getLatLonArr","arr","latLon2","lat1","lat2","lon1","lon2","NS","EW","sin","cos","atan2","compass","getCatalogNumber","Object","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('satellite.js')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'satellite.js'], factory) :\n  (global = global || self, factory(global.tlejs = {}, global.satellite));\n}(this, (function (exports, satellite_js) { 'use strict';\n\n  const _MS_IN_A_DAY = 86400000;\n  const _MS_IN_A_SECOND = 1000;\n  const _MS_IN_A_MINUTE = 60000; // Data formats for TLE orbital elements.\n\n  const _TLE_DATA_TYPES = {\n    _INT: Symbol(),\n    _FLOAT: Symbol(),\n    _CHAR: Symbol(),\n    _DECIMAL_ASSUMED: Symbol(),\n    // 12345   -> 0.12345\n    _DECIMAL_ASSUMED_E: Symbol() // 12345-2 -> 0.0012345\n\n  };\n  const _DATA_TYPES = {\n    _ARRAY: \"array\",\n    _STRING: \"string\",\n    _OBJECT: \"object\",\n    _DATE: \"date\",\n    _NAN: \"NaN\"\n  };\n\n  /**\n   * General helper that provides more useful info than JavaScript's built-in \"typeof\" operator.\n   *\n   * Example:\n   * getType([]);\n   * -> 'array'\n   */\n\n  function getType(input) {\n    const type = typeof input;\n\n    if (Array.isArray(input)) {\n      return _DATA_TYPES._ARRAY;\n    }\n\n    if (input instanceof Date) {\n      return _DATA_TYPES._DATE;\n    }\n\n    if (Number.isNaN(input)) {\n      return _DATA_TYPES._NAN;\n    }\n\n    return type;\n  }\n  /**\n   * Determines if a number is positive.\n   */\n\n  const _isPositive = num => num >= 0;\n  /**\n   * Determines the amount of digits in a number.  Used for converting a TLE's \"leading decimal\n   * assumed\" notation.\n   *\n   * Example:\n   * getDigitCount(12345);\n   * -> 5\n   */\n\n  const _getDigitCount = num => {\n    const absVal = Math.abs(num);\n    return absVal.toString().length;\n  };\n  /**\n   * Converts a TLE's \"leading decimal assumed\" notation to a float representation.\n   *\n   * Example:\n   * toLeadingDecimal(12345);\n   * -> 0.12345\n   */\n\n  const _toLeadingDecimal = num => {\n    const numDigits = _getDigitCount(num);\n\n    const zeroes = \"0\".repeat(numDigits - 1);\n    return parseFloat(num * `0.${zeroes}1`);\n  };\n  /**\n   * Converts a TLE's \"leading decimal assumed\" notation with leading zeroes to a float\n   * representation.\n   *\n   * Example:\n   * decimalAssumedEToFloat('12345-4');\n   * -> 0.000012345\n   */\n\n  const _decimalAssumedEToFloat = str => {\n    const numWithAssumedLeadingDecimal = str.substr(0, str.length - 2);\n\n    const num = _toLeadingDecimal(numWithAssumedLeadingDecimal);\n\n    const leadingDecimalPoints = parseInt(str.substr(str.length - 2, 2), 10);\n    const float = num * Math.pow(10, leadingDecimalPoints);\n    return parseFloat(float.toPrecision(5));\n  };\n  /**\n   * Converts a fractional day of the year to a timestamp.  Used for parsing the TLE epoch.\n   */\n\n  const _dayOfYearToTimeStamp = (dayOfYear, year = new Date().getFullYear()) => {\n    const yearStart = new Date(`1/1/${year} 0:0:0 Z`);\n    const yearStartMS = yearStart.getTime();\n    return Math.floor(yearStartMS + (dayOfYear - 1) * _MS_IN_A_DAY);\n  };\n  /**\n   * Converts radians (0 to 2π) to degrees (0 to 360).\n   */\n\n  const _radiansToDegrees = radians => radians * (180 / Math.PI);\n  /**\n   * Converts degrees (0 to 360) to radians (0 to 2π).\n   */\n\n  const _degreesToRadians = degrees => degrees * (Math.PI / 180);\n  /**\n   * Determines if a pair of longitude points crosses over the antemeridian, which is a\n   * pain point for mapping software.\n   */\n\n  const _crossesAntemeridian = (longitude1, longitude2) => {\n    if (!longitude1 || !longitude2) return false;\n\n    const isLong1Positive = _isPositive(longitude1);\n\n    const isLong2Positive = _isPositive(longitude2);\n\n    const haveSameSigns = isLong1Positive === isLong2Positive;\n    if (haveSameSigns) return false; // Signs don't match, so check if we're reasonably near the antemeridian (just to be sure it's\n    // not the prime meridian).\n\n    const isNearAntemeridian = Math.abs(longitude1) > 100;\n    return isNearAntemeridian;\n  };\n  /**\n   * Note: TLEs have a year 2000 style problem in 2057, because they only represent years in 2\n   * characters.  This function doesn't account for that problem.\n   *\n   * Example:\n   * _getFullYear(98);\n   * -> 1998\n   *\n   * @param {Number} twoDigitYear\n   */\n\n  function _getFullYear(twoDigitYear) {\n    const twoDigitYearInt = parseInt(twoDigitYear, 10);\n    return twoDigitYearInt < 100 && twoDigitYearInt > 56 ? twoDigitYearInt + 1900 : twoDigitYearInt + 2000;\n  }\n  /**\n   * Gets a piece of data directly from a TLE line string, and attempts to parse it based on\n   * data format.\n   *\n   * @param {Object} parsedTLE\n   * @param {(1|2)} lineNumber TLE line number.\n   * @param {Object} definition From line-1-definitions or line-2-definitions.\n   */\n\n  function getFromTLE(parsedTLE, lineNumber, definition) {\n    const {\n      name,\n      tle\n    } = parsedTLE;\n    const line = lineNumber === 1 ? tle[0] : tle[1];\n    const {\n      start,\n      length,\n      type\n    } = definition;\n    const val = line.substr(start, length);\n    let output;\n\n    switch (type) {\n      case _TLE_DATA_TYPES._INT:\n        output = parseInt(val, 10);\n        break;\n\n      case _TLE_DATA_TYPES._FLOAT:\n        output = parseFloat(val);\n        break;\n\n      case _TLE_DATA_TYPES._DECIMAL_ASSUMED:\n        output = parseFloat(`0.${val}`);\n        break;\n\n      case _TLE_DATA_TYPES._DECIMAL_ASSUMED_E:\n        output = _decimalAssumedEToFloat(val);\n        break;\n\n      case _TLE_DATA_TYPES._CHAR:\n      default:\n        output = val.trim();\n        break;\n    }\n\n    return output;\n  }\n\n  const _ERRORS = {\n    _TYPE: (context = \"\", expected = [], got = \"\") => `${context} must be of type [${expected.join(\", \")}], but got ${got}.`,\n    _NOT_PARSED_OBJECT: `Input object is malformed (should have name and tle properties).`\n  };\n  function isTLEObj(obj) {\n    return typeof obj === _DATA_TYPES._OBJECT && obj.name && obj.tle && getType(obj.tle) === _DATA_TYPES._ARRAY && obj.tle.length === 2;\n  } // For TLE parsing memoization.\n\n  const tleCache = {};\n  /**\n   * Converts string and array TLE formats into a \"parsed\" TLE in a consistent object format.\n   * Accepts 2 and 3-line (with satellite name) TLE variants in string (\\n-delimited) and array\n   * forms.\n   *\n   * Example:\n   * parseTLE(`ISS (ZARYA)\n   * 1 25544U 98067A   19285.67257269  .00001247  00000-0  29690-4 0  9993\n   * 2 25544  51.6439 138.6866 0007415 141.2524 326.3533 15.50194187193485`);\n   * ->\n   * {\n   *   name: 'ISS (ZARYA)',\n   *   tle: [\n   *     '1 25544U 98067A   19285.67257269  .00001247  00000-0  29690-4 0  9993',\n   *     '2 25544  51.6439 138.6866 0007415 141.2524 326.3533 15.50194187193485'\n   *   ]\n   * }\n   */\n\n  const acceptedTLETypes = [_DATA_TYPES._ARRAY, _DATA_TYPES._STRING, _DATA_TYPES._OBJECT];\n  function parseTLE(sourceTLE) {\n    const type = getType(sourceTLE);\n    const output = {};\n    let tleArray = [];\n    const alreadyParsed = isTLEObj(sourceTLE);\n\n    if (alreadyParsed) {\n      // This TLE has already been parsed, so there's nothing left to do.\n      return sourceTLE;\n    }\n\n    const isUnexpectedObject = !alreadyParsed && type === _DATA_TYPES._OBJECT;\n\n    if (isUnexpectedObject) {\n      // TLE is in an unexpected object format.\n      throw new Error(_ERRORS._NOT_PARSED_OBJECT);\n    } // Note: only strings and arrays will make it past this point.\n    // Check if the TLE exists in the cache.\n\n\n    const cacheKey = type === _DATA_TYPES._ARRAY ? sourceTLE[0] : sourceTLE;\n\n    if (tleCache[cacheKey]) {\n      return tleCache[cacheKey];\n    }\n\n    if (!acceptedTLETypes.includes(type)) {\n      throw new Error(_ERRORS._TYPE(\"Source TLE\", acceptedTLETypes, type));\n    } // Convert to array.\n\n\n    if (type === _DATA_TYPES._STRING) {\n      tleArray = sourceTLE.split(\"\\n\");\n    } else if (type === _DATA_TYPES._ARRAY) {\n      // Already an array, so make a copy so we don't mutate the input.\n      tleArray = Array.from(sourceTLE);\n    } // 3-line variant: remove name from array for consistency.\n\n\n    if (tleArray.length === 3) {\n      const name = tleArray[0].trim();\n      tleArray = tleArray.slice(1); // Preserve original name string for use in the getSatelliteName() getter.\n\n      output.name = name;\n    }\n\n    output.tle = tleArray.map(line => line.trim()); // Update cache.\n\n    tleCache[cacheKey] = output;\n    return output;\n  }\n  /**\n   * Determines the checksum for a single line of a TLE.\n   *\n   * Checksum = modulo 10 of sum of all numbers (including line number) + 1 for each negative\n   * sign (-).  Everything else is ignored.\n   */\n\n  function computeChecksum(tleLineStr) {\n    const charArr = tleLineStr.split(\"\"); // Remove trailing checksum.\n\n    charArr.splice(charArr.length - 1, 1);\n\n    if (charArr.length === 0) {\n      throw new Error(\"Character array empty!\", tleLineStr);\n    }\n\n    const checksum = charArr.reduce((sum, val) => {\n      const parsedVal = parseInt(val, 10);\n      const parsedSum = parseInt(sum, 10);\n\n      if (Number.isInteger(parsedVal)) {\n        return parsedSum + parsedVal;\n      }\n\n      if (val === \"-\") {\n        return parsedSum + 1;\n      }\n\n      return parsedSum;\n    });\n    return checksum % 10;\n  }\n  function lineNumberIsValid(tleObj, lineNumber) {\n    const {\n      tle\n    } = tleObj;\n    return lineNumber === parseInt(tle[lineNumber - 1][0], 10);\n  }\n  function checksumIsValid(tleObj, lineNumber) {\n    const {\n      tle\n    } = tleObj;\n    const tleLine = tle[lineNumber - 1];\n    const checksumInTLE = parseInt(tleLine[tleLine.length - 1], 10);\n    const computedChecksum = computeChecksum(tle[lineNumber - 1]);\n    return computedChecksum === checksumInTLE;\n  }\n  /**\n   * Determines if a TLE is structurally valid.\n   */\n\n  function isValidTLE(rawTLE) {\n    let tleObj;\n\n    try {\n      tleObj = parseTLE(rawTLE);\n    } catch (e) {\n      return false;\n    } // Line number checks.\n\n\n    const line1NumberIsValid = lineNumberIsValid(tleObj, 1);\n    const line2NumberIsValid = lineNumberIsValid(tleObj, 2);\n\n    if (!line1NumberIsValid || !line2NumberIsValid) {\n      return false;\n    } // Checksums\n\n\n    const line1ChecksumIsValid = checksumIsValid(tleObj, 1);\n    const line2ChecksumIsValid = checksumIsValid(tleObj, 2);\n\n    if (!line1ChecksumIsValid || !line2ChecksumIsValid) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Two-Line Element Set (TLE) format definitions, Line 1\n   * See https://en.wikipedia.org/wiki/Two-line_element_set and https://celestrak.com/columns/v04n03/\n   */\n\n  /* TLE line number. Will always return 1 for valid TLEs. */\n\n  const lineNumber1 = {\n    start: 0,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * NORAD satellite catalog number (e.g. Sputnik's rocket was number 00001).\n   * See https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n   *\n   * Range: 0 to 99999\n   * Example: 25544\n   */\n\n  const catalogNumber1 = {\n    start: 2,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Satellite classification.\n   * 'U' = unclassified\n   * 'C' = classified\n   * 'S' = secret\n   *\n   * Example: 'U'\n   */\n\n  const classification = {\n    start: 7,\n    length: 1,\n    type: _TLE_DATA_TYPES._CHAR\n  };\n  /**\n   * International Designator (COSPAR ID): Last 2 digits of launch year.\n   * 57 to 99 = 1900s, 00-56 = 2000s\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: 00 to 99\n   * Example: 98\n   */\n\n  const intDesignatorYear = {\n    start: 9,\n    length: 2,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * International Designator (COSPAR ID): Launch number of the year.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: 1 to 999\n   * Example: 67\n   */\n\n  const intDesignatorLaunchNumber = {\n    start: 11,\n    length: 3,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * International Designator  (COSPAR ID): Piece of the launch.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * Range: A to ZZZ\n   * Example: 'A'\n   */\n\n  const intDesignatorPieceOfLaunch = {\n    start: 14,\n    length: 3,\n    type: _TLE_DATA_TYPES._CHAR\n  };\n  /**\n   * Year when the TLE was generated (TLE epoch), last two digits.\n   *\n   * Range: 00 to 99\n   * Example: 17\n   */\n\n  const epochYear = {\n    start: 18,\n    length: 2,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Fractional day of the year when the TLE was generated (TLE epoch).\n   *\n   * Range: 1 to 365.99999999\n   * Example: 206.18396726\n   */\n\n  const epochDay = {\n    start: 20,\n    length: 12,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * First Time Derivative of the Mean Motion divided by two.  Defines how mean motion changes\n   * from day to day, so TLE propagators can still be used to make reasonable guesses when\n   * times are distant from the original TLE epoch.\n   *\n   * Units: Orbits / day ^ 2\n   * Example: 0.00001961\n   */\n\n  const firstTimeDerivative = {\n    start: 33,\n    length: 11,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Second Time Derivative of Mean Motion divided by six (decimal point assumed). Measures rate\n   * of change in the Mean Motion Dot so software can make reasonable guesses when times are\n   * distant from the original TLE epoch.\n   *\n   * Usually zero, unless the satellite is manuevering or in a decaying orbit.\n   *\n   * Units: Orbits / day ^ 3.\n   * Example: 0 ('00000-0' in the original TLE [= 0.00000 * 10 ^ 0])\n   */\n\n  const secondTimeDerivative = {\n    start: 44,\n    length: 8,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED_E\n  };\n  /**\n   * BSTAR drag term (decimal point assumed).  Estimates the effects of\n   * atmospheric drag on the satellite's motion.\n   *\n   * Units: EarthRadii ^ -1\n   * Example: 0.000036771 ('36771-4' in the original TLE [= 0.36771 * 10 ^ -4])\n   */\n\n  const bstarDrag = {\n    start: 53,\n    length: 8,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED_E\n  };\n  /**\n   * Private value - used by Air Force Space Command to reference the orbit model used to\n   * generate the TLE.  Will always be seen as zero externally (e.g. by \"us\", unless you are\n   * \"them\" - in which case, hello!).\n   *\n   * Example: 0\n   */\n\n  const orbitModel = {\n    start: 62,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * TLE element set number, incremented for each new TLE generated. 999 seems to mean the TLE\n   * has maxed out.\n   *\n   * Range: Technically 1 to 9999, though in practice the maximum number seems to be 999.\n   * Example: 999\n   */\n\n  const tleSetNumber = {\n    start: 64,\n    length: 4,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /*\n   * TLE line 1 checksum (modulo 10), for verifying the integrity of this line of the TLE.\n   *\n   * Range: 0 to 9\n   * Example: 3\n   */\n\n  const checksum1 = {\n    start: 68,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n\n  /**\n   * General helper to get a piece of data from the first line of a TLE.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Object} definition From `line-1-definitions.js`\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFromLine1(tle, definition, isTLEParsed = false) {\n    const parsedTLE = isTLEParsed ? tle : parseTLE(tle);\n    return getFromTLE(parsedTLE, 1, definition);\n  }\n  /**\n   * Returns the line number from line 1.  Should always return \"1\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getLineNumber1(tle, isTLEParsed) {\n    return getFromLine1(tle, lineNumber1, isTLEParsed);\n  }\n  /**\n   * Returns the Space Catalog Number (aka NORAD Catalog Number).\n   * See https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getCatalogNumber1(tle, isTLEParsed) {\n    return getFromLine1(tle, catalogNumber1, isTLEParsed);\n  }\n  /**\n   * Returns the satellite classification.  For example, an unclassified satellite will return `U`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getClassification(tle, isTLEParsed) {\n    return getFromLine1(tle, classification, isTLEParsed);\n  }\n  /**\n   * Returns the launch year (last two digits), which makes up part of the COSPAR id\n   * (international designator).  For example, a satellite launched in 1999 will return \"99\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getIntDesignatorYear(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorYear, isTLEParsed);\n  }\n  /**\n   * Returns the launch number of the year, which makes up part of the COSPAR id\n   * (international designator).  For example, the 50th launch of the year will return \"50\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getIntDesignatorLaunchNumber(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorLaunchNumber, isTLEParsed);\n  }\n  /**\n   * Returns the piece of the launch, which makes up part of the COSPAR id (international designator).\n   * For example, the first piece of the launch will return \"A\".\n   * See https://en.wikipedia.org/wiki/International_Designator\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getIntDesignatorPieceOfLaunch(tle, isTLEParsed) {\n    return getFromLine1(tle, intDesignatorPieceOfLaunch, isTLEParsed);\n  }\n  /**\n   * Returns the TLE epoch year (last two digits) when the TLE was generated.  For example, a TLE\n   * generated in 2022 will return `22`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getEpochYear(tle, isTLEParsed) {\n    return getFromLine1(tle, epochYear, isTLEParsed);\n  }\n  /**\n   * Returns the TLE epoch day of the year (day of year with fractional portion of the day) when the\n   * TLE was generated.  For example, a TLE generated on January 1 will return something like\n   * `1.18396726`.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getEpochDay(tle, isTLEParsed) {\n    return getFromLine1(tle, epochDay, isTLEParsed);\n  }\n  /**\n   * First Time Derivative of the Mean Motion divided by two, measured in orbits per day per day\n   * (orbits/day2). Defines how mean motion changes from day to day, so TLE propagators can still be\n   * used to make reasonable guesses when distant from the original TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFirstTimeDerivative(tle, isTLEParsed) {\n    return getFromLine1(tle, firstTimeDerivative, isTLEParsed);\n  }\n  /**\n   * Second Time Derivative of Mean Motion divided by six, measured in orbits per day per day per day\n   * (orbits/day3). Similar to the first time derivative, it measures rate of change in the Mean\n   * Motion Dot so software can make reasonable guesses when distant from the original TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Motion and http://castor2.ca/03_Mechanics/03_TLE/Mean_Mot_Dot.html\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getSecondTimeDerivative(tle, isTLEParsed) {\n    return getFromLine1(tle, secondTimeDerivative, isTLEParsed);\n  }\n  /**\n   * BSTAR drag term. This estimates the effects of atmospheric drag on the satellite's motion.\n   * See https://en.wikipedia.org/wiki/BSTAR\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getBstarDrag(tle, isTLEParsed) {\n    return getFromLine1(tle, bstarDrag, isTLEParsed);\n  }\n  /**\n   * Private value - used by Air Force Space Command to reference the orbit model used to generate the\n   * TLE (e.g. SGP, SGP4).  Distributed TLES will always return `0` for this value.  Note that all\n   * distributed TLEs are generated with SGP4/SDP4.\n   * See https://celestrak.com/columns/v04n03/\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getOrbitModel(tle, isTLEParsed) {\n    return getFromLine1(tle, orbitModel, isTLEParsed);\n  }\n  /**\n   * TLE element set number, incremented for each new TLE generated since launch. 999 seems to mean\n   * the TLE has maxed out.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getTleSetNumber(tle, isTLEParsed) {\n    return getFromLine1(tle, tleSetNumber, isTLEParsed);\n  }\n  /**\n   * TLE line 1 checksum (modulo 10), for verifying the integrity of this line of the TLE. Note that\n   * letters, blanks, periods, and plus signs are counted as 0, while minus signs are counted as 1.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getChecksum1(tle, isTLEParsed) {\n    return getFromLine1(tle, checksum1, isTLEParsed);\n  }\n\n  /**\n   * Two-Line Element Set (TLE) format definitions, Line 2\n   * See https://en.wikipedia.org/wiki/Two-line_element_set and https://celestrak.com/columns/v04n03/\n   */\n\n  /* TLE line number. Will always return 2 for valid TLEs. */\n\n  const lineNumber2 = {\n    start: 0,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * NORAD satellite catalog number (Sputnik's rocket was 00001).  Should match the satellite\n   * number on line 1.\n   *\n   * Range: 0 to 99999\n   * Example: 25544\n   */\n\n  const catalogNumber2 = {\n    start: 2,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /**\n   * Inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a\n   * prograde orbit and 90 to 180 degrees is a retrograde orbit.\n   *\n   * Units: degrees\n   * Range: 0 to 180\n   * Example: 51.6400\n   */\n\n  const inclination = {\n    start: 8,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Right ascension of the ascending node in degrees. Essentially, this is the angle of the\n   * satellite as it crosses northward (ascending) across the Earth's equator (equatorial\n   * plane).\n   *\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 208.9163\n   */\n\n  const rightAscension = {\n    start: 17,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Orbital eccentricity, decimal point assumed. All artifical Earth satellites have an\n   * eccentricity between 0 (perfect circle) and 1 (parabolic orbit).\n   *\n   * Range: 0 to 1\n   * Example: 0.0006317 (`0006317` in the original TLE)\n   */\n\n  const eccentricity = {\n    start: 26,\n    length: 7,\n    type: _TLE_DATA_TYPES._DECIMAL_ASSUMED\n  };\n  /**\n   * Argument of perigee. See https://en.wikipedia.org/wiki/Argument_of_perigee\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 69.9862\n   */\n\n  const perigee = {\n    start: 34,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Mean anomaly. Indicates where the satellite was located within its orbit at the time of the\n   * TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Anomaly\n   *\n   * Units: degrees\n   * Range: 0 to 359.9999\n   * Example: 25.2906\n   */\n\n  const meanAnomaly = {\n    start: 43,\n    length: 8,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Revolutions around the Earth per day (mean motion).\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * Range: 0 to 17 (theoretically)\n   * Example: 15.54225995\n   */\n\n  const meanMotion = {\n    start: 52,\n    length: 11,\n    type: _TLE_DATA_TYPES._FLOAT\n  };\n  /**\n   * Total satellite revolutions when this TLE was generated. This number seems to roll over\n   * (e.g. 99999 -> 0).\n   *\n   * Range: 0 to 99999\n   * Example: 6766\n   */\n\n  const revNumberAtEpoch = {\n    start: 63,\n    length: 5,\n    type: _TLE_DATA_TYPES._INT\n  };\n  /*\n   * TLE line 2 checksum (modulo 10), for verifying the integrity of this line of the TLE.\n   *\n   * Range: 0 to 9\n   * Example: 0\n   */\n\n  const checksum2 = {\n    start: 68,\n    length: 1,\n    type: _TLE_DATA_TYPES._INT\n  };\n\n  /**\n   * General helper to get a piece of data from the second line of a TLE.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Object} definition From `line-1-definitions.js`\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getFromLine2(tle, definition, isTLEParsed = false) {\n    const parsedTLE = isTLEParsed ? tle : parseTLE(tle);\n    return getFromTLE(parsedTLE, 2, definition);\n  }\n  /**\n   * Returns the line number from line 2.  Should always return \"2\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getLineNumber2(tle, isTLEParsed) {\n    return getFromLine2(tle, lineNumber2, isTLEParsed);\n  }\n  /**\n   * Returns the line number from line 1.  Should always return \"1\" for valid TLEs.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getCatalogNumber2(tle, isTLEParsed) {\n    return getFromLine2(tle, catalogNumber2, isTLEParsed);\n  }\n  /**\n   * Returns the inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a\n   * prograde orbit and 90 to 180 degrees is a retrograde orbit.\n   * See https://en.wikipedia.org/wiki/Orbital_inclination\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getInclination(tle, isTLEParsed) {\n    return getFromLine2(tle, inclination, isTLEParsed);\n  }\n  /**\n   * Returns the right ascension of the ascending node in degrees. Essentially, this is the angle of\n   * the satellite as it crosses northward (ascending) across the Earth's equator (equatorial plane).\n   * See https://en.wikipedia.org/wiki/Right_ascension_of_the_ascending_node\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getRightAscension(tle, isTLEParsed) {\n    return getFromLine2(tle, rightAscension, isTLEParsed);\n  }\n  /**\n   * Returns the orbital eccentricity. All artificial Earth satellites have an eccentricity between 0\n   * (perfect circle) and 1 (parabolic orbit).\n   * See https://en.wikipedia.org/wiki/Orbital_eccentricity\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getEccentricity(tle, isTLEParsed) {\n    return getFromLine2(tle, eccentricity, isTLEParsed);\n  }\n  /**\n   * Returns the argument of perigee.\n   * See https://en.wikipedia.org/wiki/Argument_of_perigee\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getPerigee(tle, isTLEParsed) {\n    return getFromLine2(tle, perigee, isTLEParsed);\n  }\n  /**\n   * Returns the Mean Anomaly. Indicates where the satellite was located within its orbit at the time\n   * of the TLE epoch.\n   * See https://en.wikipedia.org/wiki/Mean_Anomaly\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getMeanAnomaly(tle, isTLEParsed) {\n    return getFromLine2(tle, meanAnomaly, isTLEParsed);\n  }\n  /**\n   * Returns the revolutions around the Earth per day (mean motion).\n   * See https://en.wikipedia.org/wiki/Mean_Motion\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getMeanMotion(tle, isTLEParsed) {\n    return getFromLine2(tle, meanMotion, isTLEParsed);\n  }\n  /**\n   * Returns the total satellite revolutions when this TLE was generated. This number seems to roll\n   * over (e.g. 99999 -> 0).\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getRevNumberAtEpoch(tle, isTLEParsed) {\n    return getFromLine2(tle, revNumberAtEpoch, isTLEParsed);\n  }\n  /**\n   * TLE line 2 checksum (modulo 10), for verifying the integrity of this line of the TLE. Note that\n   * letters, blanks, periods, and plus signs are counted as 0, while minus signs are counted as 1.\n   *\n   * @param {String|Array} tle Two or three line TLE\n   * @param {Boolean} isTLEParsed Skips TLE parsing when true.\n   */\n\n  function getChecksum2(tle, isTLEParsed) {\n    return getFromLine2(tle, checksum2, isTLEParsed);\n  }\n\n  /**\n   * Determines COSPAR ID.\n   * See https://en.wikipedia.org/wiki/International_Designator\n   */\n\n  function getCOSPAR(tle, tleIsParsed) {\n    const partialYear = getIntDesignatorYear(tle, tleIsParsed);\n\n    const fullYear = _getFullYear(partialYear);\n\n    const launchNum = getIntDesignatorLaunchNumber(tle, tleIsParsed);\n    const launchNumWithPadding = launchNum.toString().padStart(3, 0);\n    const launchPiece = getIntDesignatorPieceOfLaunch(tle, tleIsParsed);\n    return `${fullYear}-${launchNumWithPadding}${launchPiece}`;\n  }\n  /**\n   * Determines the name of a satellite, if present in the first line of a 3-line TLE.  If not found,\n   * returns \"Unknown\" by default, or the COSPAR id when fallbackToCOSPAR is true.\n   *\n   * Example:\n   * getSatelliteName(tleStr);\n   * -> 'ISS (ZARYA)'\n   *\n   * @param {String|Array} rawTLE Input TLE.\n   * @param {Boolean} fallbackToCOSPAR Returns COSPAR id when satellite name isn't found.\n   */\n\n  function getSatelliteName(rawTLE, fallbackToCOSPAR = false) {\n    const parsedTLE = parseTLE(rawTLE);\n    const {\n      name\n    } = parsedTLE;\n\n    if (fallbackToCOSPAR) {\n      return name || getCOSPAR(parsedTLE, true);\n    } else {\n      return name || \"Unknown\";\n    }\n  }\n  /**\n   * Determines the Unix timestamp (in ms) of a TLE epoch (the time a TLE was generated).\n   *\n   * Example:\n   * getEpochTimestamp(tleStr);\n   * -> 1500956694771\n   */\n\n  function getEpochTimestamp(rawTLE) {\n    const epochDay = getEpochDay(rawTLE);\n    const epochYear = getEpochYear(rawTLE);\n    return _dayOfYearToTimeStamp(epochDay, epochYear);\n  }\n  /**\n   * Determines the average amount of milliseconds in one orbit.\n   */\n\n  function getAverageOrbitTimeMS(tle) {\n    return parseInt(_MS_IN_A_DAY / getMeanMotion(tle), 10);\n  }\n  /**\n   * Determines the average amount of minutes in one orbit.\n   */\n\n  function getAverageOrbitTimeMins(tle) {\n    return getAverageOrbitTimeMS(tle) / _MS_IN_A_MINUTE;\n  }\n  /**\n   * Determines the average amount of seconds in one orbit.\n   */\n\n  function getAverageOrbitTimeS(tle) {\n    return getAverageOrbitTimeMS(tle) / _MS_IN_A_SECOND;\n  }\n\n  const _SAT_REC_ERRORS = {\n    _DEFAULT: \"Problematic TLE with unknown error.\",\n    1: \"Mean elements, ecc >= 1.0 or ecc < -0.001 or a < 0.95 er\",\n    2: \"Mean motion less than 0.0\",\n    3: \"Pert elements, ecc < 0.0  or  ecc > 1.0\",\n    4: \"Semi-latus rectum < 0.0\",\n    5: \"Epoch elements are sub-orbital\",\n    6: \"Satellite has decayed\"\n  };\n  let cachedSatelliteInfo = {};\n  let cachedAntemeridianCrossings = {};\n  let cachedOrbitTracks = {};\n  let cachedVisibleSatellites = {\n    slowMoving: {}\n  };\n  let cachedGroundTrack = {};\n  const caches = [cachedSatelliteInfo, cachedAntemeridianCrossings, cachedOrbitTracks, cachedVisibleSatellites, cachedGroundTrack];\n  function getCacheSizes() {\n    return caches.map(cache => getObjLength);\n  }\n  /**\n   * Provides a way to clear up memory for long-running apps.\n   */\n\n  function clearCache() {\n    cachedVisibleSatellites.slowMoving = [];\n  }\n  /**\n  \t * Determines satellite position and look angles from an earth observer.\n  \t *\n  \t * Example:\n  \t * const satInfo = getSatelliteInfo(\n  \t *   tleStr,          // Satellite TLE string or array (2 or 3 line variants).\n  \t *   1501039265000,   // Unix timestamp (ms)\n  \t *   34.243889,       // Observer latitude (degrees)\n  \t *   -116.911389,     // Observer longitude (degrees)\n  \t *   0                // Observer elevation (km)\n  \t * );\n  \t *\n  \t * ->\n  \t * {\n  \t *   // satellite compass heading from observer in degrees (0 = north, 180 = south)\n  \t *   azimuth: 294.5780478624994,\n  \t *\n  \t *   // satellite elevation from observer in degrees (90 is directly overhead)\n  \t *   elevation: 81.63903620330046,\n  \t *\n  \t *   // km distance from observer to spacecraft\n  \t *   range: 406.60211015810074,\n  \t *\n  \t *   // spacecraft altitude in km\n  \t *   height: 402.9082788620108,\n\n  \t *   // spacecraft latitude in degrees\n  \t *   lat: 34.45112876592785,\n\n  \t *   // spacecraft longitude in degrees\n  \t *   lng: -117.46176597710809,\n  \t *\n  \t *   // spacecraft velocity in km/s\n  \t *   velocity: 7.675627442183371\n  \t * }\n  \t */\n\n  function getSatelliteInfo(rawTLE, rawTimestamp, observerLat, observerLng, observerHeight) {\n    const timestamp = rawTimestamp || Date.now();\n    const {\n      tle\n    } = parseTLE(rawTLE);\n    const defaultObserverPosition = {\n      lat: 36.9613422,\n      lng: -122.0308,\n      height: 0.37\n    };\n    const obsLat = observerLat || defaultObserverPosition.lat;\n    const obsLng = observerLng || defaultObserverPosition.lng;\n    const obsHeight = observerHeight || defaultObserverPosition.height; // Memoization\n\n    const cacheKey = `${tle[0]}-${timestamp}-${observerLat}-${observerLng}\n-${observerHeight}`;\n\n    if (cachedSatelliteInfo[cacheKey]) {\n      return cachedSatelliteInfo[cacheKey];\n    } // Initialize a satellite record\n\n\n    const satrec = satellite_js.twoline2satrec(tle[0], tle[1]);\n\n    if (satrec.error) {\n      throw new Error(_SAT_REC_ERRORS[satrec.error] || _SAT_REC_ERRORS._DEFAULT);\n    }\n\n    const dateObj = new Date(timestamp); // Propagate SGP4.\n\n    const positionAndVelocity = satellite_js.propagate(satrec, dateObj); // The position_velocity result is a key-value pair of ECI coordinates.\n    // These are the base results from which all other coordinates are derived.\n\n    const positionEci = positionAndVelocity.position;\n    const velocityEci = positionAndVelocity.velocity; // Set the observer position (in radians).\n\n    const observerGd = {\n      latitude: _degreesToRadians(obsLat),\n      longitude: _degreesToRadians(obsLng),\n      height: obsHeight\n    }; // Get GMST for some coordinate transforms.\n    // http://en.wikipedia.org/wiki/Sidereal_time#Definition\n\n    const gmst = satellite_js.gstime(dateObj); // Get ECF, Geodetic, Look Angles, and Doppler Factor.\n\n    const positionEcf = satellite_js.eciToEcf(positionEci, gmst);\n    const positionGd = satellite_js.eciToGeodetic(positionEci, gmst);\n    const lookAngles = satellite_js.ecfToLookAngles(observerGd, positionEcf);\n    const velocityKmS = Math.sqrt(Math.pow(velocityEci.x, 2) + Math.pow(velocityEci.y, 2) + Math.pow(velocityEci.z, 2)); // Azimuth: is simply the compass heading from the observer's position.\n\n    const {\n      azimuth,\n      elevation,\n      rangeSat\n    } = lookAngles; // Geodetic coords are accessed via `longitude`, `latitude`, `height`.\n\n    const {\n      longitude,\n      latitude,\n      height\n    } = positionGd;\n    const output = {\n      lng: satellite_js.degreesLong(longitude),\n      lat: satellite_js.degreesLat(latitude),\n      elevation: _radiansToDegrees(elevation),\n      azimuth: _radiansToDegrees(azimuth),\n      range: rangeSat,\n      height,\n      velocity: velocityKmS\n    }; // Memoization\n\n    cachedSatelliteInfo[cacheKey] = output;\n    return output;\n  }\n  /**\n   * Determines if the last antemeridian crossing has been cached.  If it has, the time (in ms)\n   * is returned, otherwise it returns false.\n   */\n\n  function getCachedLastAntemeridianCrossingTimeMS(tleObj, timeMS) {\n    const {\n      tle\n    } = tleObj;\n    const orbitLengthMS = getAverageOrbitTimeMins(tle) * 60 * 1000;\n    const tleStr = tle[0].substr(0, 30);\n    const cachedCrossingTimes = cachedAntemeridianCrossings[tleStr];\n    if (!cachedCrossingTimes) return false;\n    if (cachedCrossingTimes === -1) return cachedCrossingTimes;\n    const cachedTime = cachedCrossingTimes.filter(val => {\n      if (typeof val === \"object\" && val.tle === tle) return -1;\n      const diff = timeMS - val;\n      const isDiffPositive = diff > 0;\n      const isWithinOrbit = isDiffPositive && diff < orbitLengthMS;\n      return isWithinOrbit;\n    });\n    return cachedTime[0] || false;\n  }\n  /**\n   * Determines the last time the satellite crossed the antemeridian.  For mapping convenience\n   * and to avoid headaches, we want to avoid plotting ground tracks that cross the antemeridian.\n   */\n\n  function getLastAntemeridianCrossingTimeMS(tle, timeMS) {\n    const parsedTLE = parseTLE(tle);\n    const {\n      tle: tleArr\n    } = parsedTLE;\n    const cachedVal = getCachedLastAntemeridianCrossingTimeMS(parsedTLE, timeMS);\n\n    if (cachedVal) {\n      return cachedVal;\n    }\n\n    const time = timeMS || Date.now();\n    let step = 1000 * 60 * 10;\n    let curLngLat = [];\n    let lastLngLat = [];\n    let curTimeMS = time;\n    let didCrossAntemeridian = false;\n    let tries = 0;\n    let isDone = false;\n    const maxTries = 1000;\n\n    while (!isDone) {\n      curLngLat = getLngLat(tleArr, curTimeMS);\n      const [curLng, curLat] = curLngLat;\n      didCrossAntemeridian = _crossesAntemeridian(lastLngLat[0], curLng);\n\n      if (didCrossAntemeridian) {\n        // Back up a bit, then keep halving the step increment till we get close enough.\n        curTimeMS += step;\n        step = step > 20000 ? 20000 : step / 2;\n      } else {\n        curTimeMS -= step;\n        lastLngLat = curLngLat;\n      }\n\n      isDone = step < 500 || tries >= maxTries;\n      tries++;\n    }\n\n    const couldNotFindCrossing = tries - 1 === maxTries;\n    const crossingTime = couldNotFindCrossing ? -1 : parseInt(curTimeMS, 10);\n    const tleStr = tleArr[0];\n\n    if (!cachedAntemeridianCrossings[tleStr]) {\n      cachedAntemeridianCrossings[tleStr] = [];\n    }\n\n    if (couldNotFindCrossing) {\n      cachedAntemeridianCrossings[tleStr] = -1;\n    } else {\n      cachedAntemeridianCrossings[tleStr].push(crossingTime);\n    }\n\n    return crossingTime;\n  }\n  /**\n   * Determines current satellite position, or position at time of timestamp (optional).\n   *\n   * @param {Array|String} tle\n   * @param {Number} optionalTimestamp Unix timestamp in milliseconds.\n   */\n\n  function getLatLngObj(tle, optionalTimestamp = Date.now()) {\n    const {\n      lat,\n      lng\n    } = getSatelliteInfo(tle, optionalTimestamp);\n    return {\n      lat,\n      lng\n    };\n  }\n  /**\n   * Determines current satellite position, or position at time of timestamp (optional).\n   *\n   * @param {Array|String} tle\n   * @param {Number} optionalTimestamp Unix timestamp in milliseconds.\n   */\n\n  function getLngLat(tle, optionalTimestamp = Date.now()) {\n    const {\n      lat,\n      lng\n    } = getSatelliteInfo(tle, optionalTimestamp);\n    return [lng, lat];\n  }\n  /**\n   * Determines the position of the satellite at the time the TLE was generated.\n   *\n   * @param {Array|String} tle\n   */\n\n  function getLngLatAtEpoch(tle) {\n    return getLngLat(tle, getEpochTimestamp(tle));\n  } // TODO: cache geosync and erroring satellites and don't recompute on next pass.\n\n  function getVisibleSatellites({\n    observerLat,\n    observerLng,\n    observerHeight = 0,\n    tles = [],\n    elevationThreshold = 0,\n    timestampMS = Date.now()\n  }) {\n    return tles.reduce((visibleSats, tleArr, index) => {\n      // Don't waste time reprocessing geosync.\n      const cacheKey = tleArr[1];\n      const cachedVal = cachedVisibleSatellites.slowMoving[cacheKey];\n\n      if (cachedVal) {\n        const {\n          info\n        } = cachedVal;\n        const {\n          elevation: cachedElevation\n        } = info;\n        return cachedElevation >= elevationThreshold ? visibleSats.concat(cachedVal) : visibleSats;\n      }\n\n      let info;\n\n      try {\n        info = getSatelliteInfo(tleArr, timestampMS, observerLat, observerLng, observerHeight);\n      } catch (e) {\n        // Don't worry about decayed sats, just move on.\n        // TODO cache error\n        return visibleSats;\n      }\n\n      const {\n        elevation,\n        velocity,\n        range\n      } = info;\n      const isSlowMoving = velocity / range < 0.001;\n\n      if (isSlowMoving) {\n        cachedVisibleSatellites.slowMoving[cacheKey] = {\n          tleArr,\n          info\n        };\n      }\n\n      return elevation >= elevationThreshold ? visibleSats.concat({\n        tleArr,\n        info\n      }) : visibleSats;\n    }, []);\n  }\n  function* getNextPosition(tleArr, startTimeMS, stepMS) {\n    let curTimeMS = startTimeMS - stepMS;\n\n    while (true) {\n      curTimeMS += stepMS;\n      yield {\n        curTimeMS,\n        lngLat: getLngLat(tleArr, curTimeMS)\n      };\n    }\n  }\n  function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  /**\n   * Generates an array of lng/lat pairs representing a ground track (orbit track), starting\n   * from startTimeMS and continuing until just before crossing the antemeridian, which is considered the end\n   * of the orbit for convenience.\n   *\n   * Consider pairing this with getLastAntemeridianCrossingTimeMS() to create a full orbit path (see usage\n   * in getGroundTracks()).\n   */\n\n  function getOrbitTrack({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    sleepMS = 0,\n    jobChunkSize = 1000,\n    maxTimeMS = 6000000,\n    isLngLatFormat = true\n  }) {\n    return new Promise(async (resolve, reject) => {\n      const {\n        tle: tleArr\n      } = parseTLE(tle);\n      const startS = (startTimeMS / 1000).toFixed();\n      const cacheKey = `${tleArr[0]}-${startS}-${stepMS}-${isLngLatFormat}`;\n\n      if (cachedOrbitTracks[cacheKey]) {\n        resolve(cachedOrbitTracks[cacheKey]);\n        return;\n      }\n\n      const generator = getNextPosition(tleArr, startTimeMS, stepMS);\n      let step = 0;\n      let isDone = false;\n      let coords = [];\n      let lastLng;\n\n      while (!isDone) {\n        const {\n          curTimeMS,\n          lngLat\n        } = generator.next().value;\n        const [curLng, curLat] = lngLat;\n\n        const doesCrossAntemeridian = _crossesAntemeridian(lastLng, curLng);\n\n        const doesExceedTime = maxTimeMS && curTimeMS - startTimeMS > maxTimeMS;\n        isDone = doesCrossAntemeridian || doesExceedTime;\n\n        if (isLngLatFormat) {\n          coords.push(lngLat);\n        } else {\n          coords.push([curLat, curLng]);\n        }\n\n        if (sleepMS && step % jobChunkSize === 0) {\n          // Chunk is processed, so cool off a bit.\n          await sleep(sleepMS);\n        }\n\n        lastLng = curLng;\n        step++;\n      }\n\n      cachedOrbitTracks[cacheKey] = coords;\n      resolve(coords);\n    });\n  }\n  /**\n   *\n   */\n\n  function getOrbitTrackSync({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    maxTimeMS = 6000000,\n    isLngLatFormat = true\n  }) {\n    const {\n      tle: tleArr\n    } = parseTLE(tle);\n    const startS = (startTimeMS / 1000).toFixed();\n    const cacheKey = `${tleArr[0]}-${startS}-${stepMS}-${isLngLatFormat}`;\n\n    if (cachedOrbitTracks[cacheKey]) {\n      return cachedOrbitTracks[cacheKey];\n    }\n\n    let isDone = false;\n    let coords = [];\n    let lastLng;\n    let curTimeMS = startTimeMS;\n\n    while (!isDone) {\n      const curLngLat = getLngLat(tleArr, curTimeMS);\n      const [curLng, curLat] = curLngLat;\n\n      const doesCrossAntemeridian = _crossesAntemeridian(lastLng, curLng);\n\n      const doesExceedTime = maxTimeMS && curTimeMS - startTimeMS > maxTimeMS;\n      isDone = doesCrossAntemeridian || doesExceedTime;\n\n      if (isLngLatFormat) {\n        coords.push(curLngLat);\n      } else {\n        coords.push([curLat, curLng]);\n      }\n\n      lastLng = curLng;\n      curTimeMS += stepMS;\n    }\n\n    cachedOrbitTracks[cacheKey] = coords;\n    return coords;\n  }\n  /**\n   * Calculates three orbit arrays of latitude/longitude pairs.\n   * TODO: just calculate future orbits\n   *\n   * @param {Array|String} options.tle\n   * @param {Number} startTimeMS Unix timestamp in milliseconds.\n   * @param {Number} stepMS Time in milliseconds between points on the ground track.\n   * @param {Boolean} isLngLatFormat Formats coords in [lng, lat] order when true, [lat, lng] when false.\n   * \n   *\n   * Example:\n   * const threeOrbitsArr = await getGroundTracks({ tle: tleStr });\n   * ->\n   * [\n   *   // previous orbit\n   *   [\n   *     [ 45.85524291891481, -179.93297540317567 ],\n   *     ...\n   *   ],\n   *\n   *   // current orbit\n   *   [\n   *     [ 51.26165992503701, -179.9398612198045 ],\n   *     ...\n   *   ],\n   *\n   *   // next orbit\n   *   [\n   *     [ 51.0273714070371, -179.9190165549038 ],\n   *     ...\n   *   ]\n   * ]\n   */\n\n  function getGroundTracks({\n    tle,\n    startTimeMS = Date.now(),\n    stepMS = 1000,\n    isLngLatFormat = true\n  }) {\n    return new Promise(async (resolve, reject) => {\n      const parsedTLE = parseTLE(tle);\n      const orbitTimeMS = getAverageOrbitTimeMS(parsedTLE);\n      const curOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, startTimeMS);\n      const foundCrossing = curOrbitStartMS !== -1;\n\n      if (!foundCrossing) {\n        // Geosync or unusual orbit, so just return a partial orbit track.\n        const partialGroundTrack = await getOrbitTrack({\n          tle: parsedTLE,\n          startTimeMS,\n          stepMS: _MS_IN_A_MINUTE,\n          maxTimeMS: _MS_IN_A_DAY / 4,\n          isLngLatFormat\n        });\n        resolve([partialGroundTrack]);\n        return;\n      }\n\n      const lastOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, // TODO: fix this magic math\n      curOrbitStartMS - 10000);\n      const nextOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, // TODO: fix this magic math\n      curOrbitStartMS + orbitTimeMS + 1000 * 60 * 30);\n      const groundTrackPromises = [getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: lastOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      }), getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: curOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      }), getOrbitTrack({\n        tle: parsedTLE,\n        startTimeMS: nextOrbitStartMS,\n        stepMS,\n        isLngLatFormat\n      })];\n      const threeOrbitTracks = await Promise.all(groundTrackPromises);\n      resolve(threeOrbitTracks);\n    });\n  }\n  /**\n   * Calculates three orbit arrays of latitude/longitude pairs.\n   *\n   * Example:\n   * const threeOrbitsArr = getGroundTrackSync({ tle: tleStr });\n   * ->\n   * [\n   *   // previous orbit\n   *   [\n   *     [ 45.85524291891481, -179.93297540317567 ],\n   *     ...\n   *   ],\n   *\n   *   // current orbit\n   *   [\n   *     [ 51.26165992503701, -179.9398612198045 ],\n   *     ...\n   *   ],\n   *\n   *   // next orbit\n   *   [\n   *     [ 51.0273714070371, -179.9190165549038 ],\n   *     ...\n   *   ]\n   * ]\n   */\n\n  function getGroundTracksSync({\n    tle,\n    stepMS = 1000,\n    optionalTimeMS = Date.now(),\n    isLngLatFormat = true\n  }) {\n    const parsedTLE = parseTLE(tle);\n    const {\n      tle: tleArr\n    } = parsedTLE;\n    const orbitTimeMS = getAverageOrbitTimeMS(tleArr);\n    const curOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, optionalTimeMS);\n    const foundCrossing = curOrbitStartMS !== -1;\n\n    if (!foundCrossing) {\n      // Geosync or unusual orbit, so just return a partial orbit track.\n      const partialGroundTrack = getOrbitTrackSync({\n        tle: parsedTLE,\n        startTimeMS: timeMS,\n        stepMS: _MS_IN_A_MINUTE,\n        maxTimeMS: _MS_IN_A_DAY / 4\n      });\n      return partialGroundTrack;\n    }\n\n    const lastOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, curOrbitStartMS - 10000);\n    const nextOrbitStartMS = getLastAntemeridianCrossingTimeMS(parsedTLE, curOrbitStartMS + orbitTimeMS + 1000 * 60 * 30);\n    const orbitStartTimes = [lastOrbitStartMS, curOrbitStartMS, nextOrbitStartMS];\n    const orbitLatLons = orbitStartTimes.map(orbitStartMS => {\n      return getOrbitTrackSync({\n        tle: parsedTLE,\n        startTimeMS: orbitStartMS,\n        stepMS,\n        isLngLatFormat\n      });\n    });\n    return orbitLatLons;\n  }\n  /**\n   * Determes the compass bearing from the perspective of the satellite.  Useful for 3D / pitched\n   * map perspectives.\n   *\n   * TODO: a bit buggy at extreme parts of orbits, where latitude hardly changes.\n   */\n\n  function getSatBearing(tle, customTimeMS) {\n    const parsedTLE = this.parseTLE(tle);\n    const timeMS = customTimeMS || Date.now();\n    const latLon1 = this.getLatLonArr(parsedTLE.arr, timeMS);\n    const latLon2 = this.getLatLonArr(parsedTLE.arr, timeMS + 10000);\n\n    const doesCrossAntemeridian = _crossesAntemeridian(latLon1[1], latLon2[1]);\n\n    if (doesCrossAntemeridian) {\n      // TODO: fix\n      return {}; // return this.getSatBearing(tle, customTimeMS + 10000);\n    }\n\n    const lat1 = _degreesToRadians(latLon1[0]);\n\n    const lat2 = _degreesToRadians(latLon2[0]);\n\n    const lon1 = _degreesToRadians(latLon1[1]);\n\n    const lon2 = _degreesToRadians(latLon2[1]);\n\n    const NS = lat1 >= lat2 ? \"S\" : \"N\";\n    const EW = lon1 >= lon2 ? \"W\" : \"E\";\n    const y = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    const degrees = _radiansToDegrees(Math.atan2(y, x));\n\n    return {\n      degrees,\n      compass: `${NS}${EW}`\n    };\n  }\n\n  exports.clearCache = clearCache;\n  exports.computeChecksum = computeChecksum;\n  exports.getAverageOrbitTimeMS = getAverageOrbitTimeMS;\n  exports.getAverageOrbitTimeMins = getAverageOrbitTimeMins;\n  exports.getAverageOrbitTimeS = getAverageOrbitTimeS;\n  exports.getBstarDrag = getBstarDrag;\n  exports.getCOSPAR = getCOSPAR;\n  exports.getCacheSizes = getCacheSizes;\n  exports.getCatalogNumber = getCatalogNumber1;\n  exports.getCatalogNumber1 = getCatalogNumber1;\n  exports.getCatalogNumber2 = getCatalogNumber2;\n  exports.getChecksum1 = getChecksum1;\n  exports.getChecksum2 = getChecksum2;\n  exports.getClassification = getClassification;\n  exports.getEccentricity = getEccentricity;\n  exports.getEpochDay = getEpochDay;\n  exports.getEpochTimestamp = getEpochTimestamp;\n  exports.getEpochYear = getEpochYear;\n  exports.getFirstTimeDerivative = getFirstTimeDerivative;\n  exports.getGroundTracks = getGroundTracks;\n  exports.getGroundTracksSync = getGroundTracksSync;\n  exports.getInclination = getInclination;\n  exports.getIntDesignatorLaunchNumber = getIntDesignatorLaunchNumber;\n  exports.getIntDesignatorPieceOfLaunch = getIntDesignatorPieceOfLaunch;\n  exports.getIntDesignatorYear = getIntDesignatorYear;\n  exports.getLastAntemeridianCrossingTimeMS = getLastAntemeridianCrossingTimeMS;\n  exports.getLatLngObj = getLatLngObj;\n  exports.getLineNumber1 = getLineNumber1;\n  exports.getLineNumber2 = getLineNumber2;\n  exports.getLngLatAtEpoch = getLngLatAtEpoch;\n  exports.getMeanAnomaly = getMeanAnomaly;\n  exports.getMeanMotion = getMeanMotion;\n  exports.getOrbitModel = getOrbitModel;\n  exports.getOrbitTrack = getOrbitTrack;\n  exports.getOrbitTrackSync = getOrbitTrackSync;\n  exports.getPerigee = getPerigee;\n  exports.getRevNumberAtEpoch = getRevNumberAtEpoch;\n  exports.getRightAscension = getRightAscension;\n  exports.getSatBearing = getSatBearing;\n  exports.getSatelliteInfo = getSatelliteInfo;\n  exports.getSatelliteName = getSatelliteName;\n  exports.getSecondTimeDerivative = getSecondTimeDerivative;\n  exports.getTleSetNumber = getTleSetNumber;\n  exports.getVisibleSatellites = getVisibleSatellites;\n  exports.isValidTLE = isValidTLE;\n  exports.parseTLE = parseTLE;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}